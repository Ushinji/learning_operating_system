     1                                  ; **********************************************
     2                                  ; カーネルを読み込む
     3                                  ; **********************************************
     4                                  %include "../include/macro.s"
     1                              <1> ; %macro <マクロ名> <引数の数>
     2                              <1> ; 1-*: 1つ以上の引数が指定されることを示す
     3                              <1> ; .nolist: マクロのリスト出力を抑止
     4                              <1> %macro  cdecl 1-*.nolist
     5                              <1> 
     6                              <1>     ; -------------------------------------------------
     7                              <1>     ; 引数リストから、呼び出し関数の引数を末尾から順にpushする
     8                              <1>     ; -------------------------------------------------
     9                              <1>     ; %rep <number>: %rep -> %endrepの間を指定回数分ループする
    10                              <1>     ; %0 - 1: 呼び出し関数への引数の数(%0は引数の数を表す。引数の数から、呼び出し関数そのものを数から引くと呼び出し関数への引数の数となる)
    11                              <1>     %rep    %0 - 1
    12                              <1>         ; 引数リストの末尾の値をpushする
    13                              <1>         ; %{-1:-1}: 引数リストの末尾を表す
    14                              <1>         push    %{-1:-1}
    15                              <1> 
    16                              <1>         ; %rotate: 引数リストを指定した数だけずらす
    17                              <1>         ; 今回は末尾から引数をpushしたいので、負の数を指定し右方向へ動かす
    18                              <1>         ; ※動作例
    19                              <1>         ; [1, 2, 3, 4] -> (%rotate -1) -> [4, 1, 2, 3]
    20                              <1>         %rotate -1
    21                              <1>     %endrep
    22                              <1> 
    23                              <1>     ; 引数リストの順番を元に戻す
    24                              <1>     %rotate - 1
    25                              <1> 
    26                              <1>     ; 関数呼び出し
    27                              <1>     call    %1
    28                              <1>     
    29                              <1>     ; 引数が与えられている場合
    30                              <1>     %if 1 < %0
    31                              <1>         ; 呼び出し関数への引数分だけスタックの破棄(スタックポインタ(SP)の調整)
    32                              <1>         ; __BITS__: ビットモード判定(実行環境に応じた値(16 or 32 or 64)が得られる)
    33                              <1>         ; ビットモードを3ビット分右にシフト(1/8)すると、バイトサイズが得られる
    34                              <1>         ; * 16ビットモード: 2バイト
    35                              <1>         ; * 32ビットモード: 4バイト
    36                              <1>         ; * 64ビットモード: 8バイト
    37                              <1>         add sp, (__BITS__ >> 3) * (%0 - 1)
    38                              <1>     %endif
    39                              <1> 
    40                              <1> %endmacro
    41                              <1> 
    42                              <1> struc drive
    43 00000000 <res 00000002>      <1>     .no resw 1      ; ドライブ番号
    44 00000002 <res 00000002>      <1>     .cyln resw 1    ; シリンダ
    45 00000004 <res 00000002>      <1>     .head resw 1    ; ヘッド
    46 00000006 <res 00000002>      <1>     .sect resw 1    ; セクタ
    47                              <1> endstruc
     5                                  %include "../include/define.s"
     1                              <1> BOOT_SIZE equ (1024 * 8)
     2                              <1> KERNEL_SIZE equ (1024 * 8)
     3                              <1> 
     4                              <1> BOOT_LOAD equ 0x7C00
     5                              <1> BOOT_END equ (BOOT_LOAD + BOOT_SIZE)
     6                              <1> 
     7                              <1> KERNEL_LOAD equ 0x0010_1000
     8                              <1> 
     9                              <1> SECT_SIZE equ (512)
    10                              <1> 
    11                              <1> BOOT_SECT equ (BOOT_SIZE / SECT_SIZE)
    12                              <1> KERNEL_SECT equ (KERNEL_SIZE / SECT_SIZE)
    13                              <1> 
    14                              <1> E820_RECORD_SIZE equ 20
     6                                  
     7                                          ORG     BOOT_LOAD
     8                                  
     9                                  entry:
    10 00000000 EB58                            jmp     ipl
    11 00000002 90<rept>                        times 90 - ($ - $$) db 0x90
    12                                  ipl:
    13 0000005A FA                              cli                                     ; BIOSからの割り込みを禁止
    14 0000005B B80000                          mov     ax, 0x0000                      ; Accumulate(蓄積) Register = 0x0000
    15 0000005E 8ED8                            mov     ds, ax                          ; Data Segment  = 0x0000
    16 00000060 8EC0                            mov     es, ax                          ; Extra Segment = 0x0000
    17 00000062 8ED0                            mov     ss, ax                          ; Stack Segment = 0x0000
    18 00000064 BC007C                          mov     sp, BOOT_LOAD                   ; Stack Point   = 0x7C00
    19                                  
    20 00000067 FB                              sti                                     ; BIOSからの割り込みを許可
    21                                  
    22 00000068 8816[C600]                      mov     [BOOT + drive.no], dl           ; ブートドライブを保存
    23                                  
    24 0000006C 68[9900]E85C0083C4-             cdecl   puts, .s0
    24 00000074 02                 
    25                                  
    26                                          ; 残りのセクタをすべて読み込む
    27 00000075 BB0F00                          mov     bx, BOOT_SECT - 1               ; BX=残りのブートセクタ数
    28 00000078 B9007E                          mov     cx, BOOT_LOAD + SECT_SIZE       ; CX=次のロードアドレス
    29                                  
    30 0000007B 515368[C600]E8A900-             cdecl   read_chs, BOOT, bx, cx          ; セクタ読み込み実行
    30 00000083 83C406             
    31                                  
    32 00000086 39D8                            cmp     ax, bx                          ; 戻り値(AX) != 残りのセクタ数(bx) -> 再起動する
    33 00000088 740C                    .10Q:   jz      .10E
    34 0000008A 68[B200]E83E0083C4-     .10T:   cdecl   puts, .e0
    34 00000092 02                 
    35 00000093 E85700                          call    reboot
    36                                  .10E:
    37                                  
    38                                          ; 次ステージへ移行
    39 00000096 E9CF05                          jmp     stage_2
    40                                  
    41                                  ; データ定義
    42                                  ; 0x0A(LF.カーソル位置を一行下げる), 0x0D(CR.カーソル位置を左端に移動する)
    43 00000099 426F6F74696E672E2E-     .s0     db      "Booting....", 0x0A, 0x0D, 0
    43 000000A2 2E2E0A0D00         
    44 000000A7 2D2D2D2D2D2D2D2D0A-     .s1     db      "--------", 0x0A, 0x0D, 0
    44 000000B0 0D00               
    45 000000B2 4572726F723A736563-     .e0     db      "Error:sector read", 0x0A, 0x0D, 0
    45 000000BB 746F7220726561640A-
    45 000000C4 0D00               
    46                                  
    47                                  ; ブートドライブに関する情報
    48                                  ALIGN 2, db 0                                   ; ALIGNディレクティブ。データを2バイト境界で配置するように指示
    49                                  BOOT:
    50                                          istruc drive
    51 000000C6 0000                                 at drive.no,       dw  0           ; ドライブ番号
    52 000000C8 0000                                 at drive.cyln,     dw  0           ; C: シリンダ
    53 000000CA 0000                                 at drive.head,     dw  0           ; H: ヘッド
    54 000000CC 0200                                 at drive.sect,     dw  2           ; S: セクタ
    55                                          iend
    56                                          
    57                                  ; モジュール読み込み
    58                                  %include        "../modules/real/puts.s"
     1                              <1> ; ******************************
     2                              <1> ; void puts(str);
     3                              <1> ; -----------------
     4                              <1> ; str: 文字列のアドレス
     5                              <1> ; -----------------
     6                              <1> ; ******************************
     7                              <1> 
     8                              <1> ; // ****************
     9                              <1> ; // レジスタ位置関係
    10                              <1> ; // ****************
    11                              <1> ;   + 4 | str
    12                              <1> ;   + 2 | 戻り番地
    13                              <1> ; BP+ 0 | BP
    14                              <1> 
    15                              <1> puts:
    16                              <1>     ; スタックフレームの構築
    17 000000CE 55                  <1>     push    bp
    18 000000CF 89E5                <1>     mov     bp, sp
    19                              <1> 
    20                              <1>     ; レジスタの保存
    21 000000D1 50                  <1>     push    ax              ;AX: Accumulate Register
    22 000000D2 53                  <1>     push    bx              ;BX: Base Register
    23 000000D3 56                  <1>     push    si              ;SI: Source Register。ストリーム操作コマンド（たとえば MOV命令）でのソース（入力元）へのポインタとして使用
    24                              <1> 
    25                              <1>     ; 引数取得
    26 000000D4 8B7604              <1>     mov     si, [bp + 4]
    27                              <1> 
    28                              <1>     ; 処理開始
    29 000000D7 B40E                <1>     mov     ah, 0x0E        ; AH(AXの上位(Hight)8bit)に、テレタイプ式1文字出力を設定
    30 000000D9 BB0000              <1>     mov     bx, 0x0000      ; ページ番号と文字色を0に設定
    31 000000DC FC                  <1>     cld                     ; Clear Direction Flag. DF=0で+方向に設定
    32                              <1> .10L:
    33                              <1>     ; LODSB命令: SIレジスタに指定されたアドレスから1バイト分のデータをALレジスタに読み込む。
    34                              <1>     ; そして、SIレジスタの値を1加算(or減算)を行う。今回はDF=0のため加算される)
    35 000000DD AC                  <1>     lodsb
    36                              <1>     
    37                              <1>     ; ALレジスタを比較し0x00(終端文字)の場合は処理終了
    38                              <1>     ; 終端文字ではない場合は、該当文字の文字を出力し、処理を繰り返す
    39 000000DE 3C00                <1>     cmp     al, 0
    40 000000E0 7404                <1>     je      .10E
    41 000000E2 CD10                <1>     int     0x10            ; ビデオBIOSコール(INT10)
    42 000000E4 EBF7                <1>     jmp     .10L
    43                              <1> .10E:
    44                              <1> 
    45                              <1>     ; レジスタの復帰
    46 000000E6 5E                  <1>     pop si
    47 000000E7 5B                  <1>     pop bx
    48 000000E8 58                  <1>     pop ax
    49                              <1> 
    50                              <1>     ; スタックフレームの破棄
    51 000000E9 89EC                <1>     mov sp, bp
    52 000000EB 5D                  <1>     pop bp
    53                              <1> 
    54                              <1>     ; 呼び出し元へ戻る
    55 000000EC C3                  <1>     ret
    59                                  %include        "../modules/real/reboot.s"
     1                              <1> reboot:
     2                              <1>     ; 再起動の説明を出力
     3 000000ED 68[0901]E8DBFF83C4- <1>     cdecl   puts, .s0
     3 000000F5 02                  <1>
     4                              <1> 
     5                              <1> .10L:
     6                              <1>     ; キー入力待ち
     7 000000F6 B410                <1>     mov     ah, 0x10
     8 000000F8 CD16                <1>     int     0x16
     9                              <1> 
    10                              <1>     ; キー入力が空白文字ではない場合、再度キー入力待ちへ戻る
    11 000000FA 3C20                <1>     cmp     al, ' '
    12 000000FC 75F8                <1>     jne     .10L
    13                              <1> 
    14                              <1>     ; 改行出力
    15 000000FE 68[2701]E8CAFF83C4- <1>     cdecl   puts, .s1
    15 00000106 02                  <1>
    16                              <1> 
    17                              <1>     ; 再起動
    18 00000107 CD19                <1>     int     0x19
    19                              <1> 
    20                              <1> 
    21                              <1>     ; 文字列データ
    22 00000109 0A0D50757368205350- <1> .s0     db 0x0A, 0x0D, "Push SPACE Key to reboot...", 0
    22 00000112 414345204B65792074- <1>
    22 0000011B 6F207265626F6F742E- <1>
    22 00000124 2E2E00              <1>
    23 00000127 0A0D0A0D00          <1> .s1     db 0x0A, 0x0D, 0x0A, 0x0D, 0
    24                              <1> 
    60                                  %include        "../modules/real/read_chs.s"
     1                              <1> ; int read_chs(drive, sect, dst);
     2                              <1> ; @params drive :drive構造体のアドレス
     3                              <1> ; @params sect  :読み出しセクタ数
     4                              <1> ; @params dst   :読み出し先アドレス 
     5                              <1> ; @return       :読み込んだセクタ数
     6                              <1> 
     7                              <1> 
     8                              <1> ; // ****************
     9                              <1> ; // レジスタ位置関係
    10                              <1> ; // ****************
    11                              <1> ;   + 8 | dst
    12                              <1> ;   + 6 | sect
    13                              <1> ;   + 4 | drive
    14                              <1> ;   + 2 | 戻り番地
    15                              <1> ; BP+ 0 | BP
    16                              <1> ; -----------------
    17                              <1> ;   - 2 | retry = 3(読み込みリトライ回数)
    18                              <1> ;   - 4 | sect  = 0(読み込みセクタ数)
    19                              <1> 
    20                              <1> read_chs:
    21                              <1>     ; スタックフレームの構築
    22 0000012C 55                  <1>     push    bp
    23 0000012D 89E5                <1>     mov     bp, sp
    24 0000012F 6A03                <1>     push    3
    25 00000131 6A00                <1>     push    0       
    26                              <1> 
    27                              <1>     ; レジスタの保存
    28 00000133 53                  <1>     push    bx
    29 00000134 51                  <1>     push    cx
    30 00000135 52                  <1>     push    dx
    31 00000136 06                  <1>     push    es
    32 00000137 56                  <1>     push    si
    33                              <1> 
    34                              <1>     ; 処理の開始
    35 00000138 8B7604              <1>     mov     si, [bp + 4]                ; drive構造体のアドレスを取得
    36                              <1>     
    37                              <1>     ; CXレジスタの設定
    38 0000013B 8A6C02              <1>     mov     ch, [si + drive.cyln + 0]   ; CH = シリンダ番号(下位バイト)
    39 0000013E 8A4C03              <1>     mov     cl, [si + drive.cyln + 1]   ; CL = シリンダ番号(上位バイト)
    40 00000141 C0E106              <1>     shl     cl, 6                       ; CL <<= 6; 上位2ビットにシフト 0x11 -> 0x110000
    41 00000144 0A4C06              <1>     or      cl, [si + drive.sect]       ; CL |= セクタ番号(0x110000 | 0x1 = 0x110001)
    42                              <1> 
    43                              <1>     ; セクタ読み込み
    44 00000147 8A7404              <1>     mov     dh, [si + drive.head]       ; DH = ヘッド取得
    45 0000014A 8A14                <1>     mov     dl, [si + 0]                ; DL = ドライブ番号
    46 0000014C B80000              <1>     mov     ax, 0x0000                  ; AX = 0x0000
    47 0000014F 8EC0                <1>     mov     es, ax                      ; ES = セグメント
    48 00000151 8B5E08              <1>     mov     bx, [bp + 8]                ; BX = コピー先(dst)
    49                              <1> .10L:
    50 00000154 B402                <1>     mov     ah, 0x02                    ; AH = セクタ読み込み命令
    51 00000156 8A4606              <1>     mov     al, [bp + 6]                ; AL = 読み込みセクタ数(sect)
    52                              <1> 
    53 00000159 CD13                <1>     int     0x13                        ; セクタ読み込み実行: BIOS(0x13, 0x02): セクタ読み出し
    54 0000015B 7304                <1>     jnc     .11E                        ; 
    55 0000015D B000                <1>     mov     al, 0
    56 0000015F EB0C                <1>     jmp     .10E
    57                              <1> .11E:
    58 00000161 3C00                <1>     cmp     al, 0                       ; 読み込みセクタ数を0
    59 00000163 7508                <1>     jne     .10E
    60                              <1> 
    61 00000165 B80000              <1>     mov     ax, 0
    62 00000168 FF4EFE              <1>     dec     word [bp - 2]               ; リトライ回数をデクリメント
    63 0000016B 75E7                <1>     jnz     .10L                        ; 一行前のデクリメント結果が0でない場合、ループする
    64                              <1> .10E:
    65 0000016D B400                <1>     mov     ah, 0                       ; ステータス情報を破棄
    66                              <1> 
    67                              <1>     ; レジスタの復帰
    68 0000016F 5E                  <1>     pop     si
    69 00000170 07                  <1>     pop     es
    70 00000171 5A                  <1>     pop     dx
    71 00000172 59                  <1>     pop     cx
    72 00000173 5B                  <1>     pop     bx
    73                              <1> 
    74                              <1>     ; スタックフレームの破棄
    75 00000174 89EC                <1>     mov     sp, bp
    76 00000176 5D                  <1>     pop     bp
    77                              <1> 
    78 00000177 C3                  <1>     ret
    61                                  
    62                                          ; プートフラグの定義
    63 00000178 00<rept>                        times 510 - ($ - $$) db 0x00
    64 000001FE 55AA                            db 0x55, 0xAA
    65                                  
    66                                  ; リアルモード時に取得した情報
    67                                  FONT:
    68 00000200 0000                    .seg: dw 0
    69 00000202 0000                    .off: dw 0
    70                                  ACPI_DATA:
    71 00000204 00000000                .adr: dd 0
    72 00000208 00000000                .len: dd 0
    73                                  
    74                                  ; モジュール(先頭512バイト以降に配置)
    75                                  %include        "../modules/real/itoa.s"
     1                              <1> ; ******************************
     2                              <1> ; void itos(num, buff, size, radix, flag);
     3                              <1> ; (Int TO Ascii)
     4                              <1> ; -----------------
     5                              <1> ; num   : 変換対象の数値
     6                              <1> ; buff  : 保存先のバッファアドレス
     7                              <1> ; size  : 保存先のバッファサイズ
     8                              <1> ; radix : 基数(2, 8, 10, 16のいずれか)
     9                              <1> ; flag  : ビット定義フラグ
    10                              <1> ;         B2: 空白を'0'で埋める
    11                              <1> ;         B1: '+/-'符号を追加
    12                              <1> ;         B0: 値を符号付変数として扱う
    13                              <1> ; -----------------
    14                              <1> ; ******************************
    15                              <1> 
    16                              <1> ; // ****************
    17                              <1> ; // レジスタ位置関係
    18                              <1> ; // ****************
    19                              <1> ;   + 12 | flag
    20                              <1> ;   + 10 | radix
    21                              <1> ;   + 8  | size
    22                              <1> ;   + 6  | buff
    23                              <1> ;   + 4  | num
    24                              <1> ;   + 2  | 戻り番地
    25                              <1> ; BP+ 0  | BP
    26                              <1> 
    27                              <1> itoa:
    28                              <1>         ; スタックフレームの構築
    29 0000020C 55                  <1>         push    bp
    30 0000020D 89E5                <1>         mov     bp, sp
    31                              <1> 
    32                              <1>         ; レジスタの保存
    33 0000020F 50                  <1>         push    ax
    34 00000210 53                  <1>         push    bx
    35 00000211 51                  <1>         push    cx
    36 00000212 52                  <1>         push    dx
    37 00000213 56                  <1>         push    si
    38 00000214 57                  <1>         push    di
    39                              <1> 
    40                              <1>         ; 引数取得
    41 00000215 8B4604              <1>         mov     ax, [bp + 4]        ; num:  変換対象の数値
    42 00000218 8B7606              <1>         mov     si, [bp + 6]        ; buff: 変換先のバッファアドレス
    43 0000021B 8B4E08              <1>         mov     cx, [bp + 8]        ; size: バッファサイズ
    44                              <1> 
    45 0000021E 89F7                <1>         mov     di, si              ; バッファの末尾を取得: di = buff[size - 1]
    46 00000220 01CF                <1>         add     di, cx              ; di = buff + size
    47 00000222 4F                  <1>         dec     di                  ; di = di - 1
    48                              <1>         
    49 00000223 8B5E0C              <1>         mov     bx, word [bp + 12]  ; flag: 変換オプション
    50                              <1> 
    51                              <1> 
    52                              <1>         ; ------------------
    53                              <1>         ; 符号付き判定
    54                              <1>         ; ------------------
    55 00000226 F7C30100            <1>         test    bx, 0b0001  ; test <1>, <2>: 与えられた２つの値の論理積を行い、結果が0であればゼロフラグ(ZF)を立てる
    56 0000022A 7408                <1> .10Q:   je      .10E        ; je: ゼロフラグ(ZF)をチェックして、フラグが立っていれば指定ラベルへ移動する
    57 0000022C 83F800              <1>         cmp     ax, 0       ; 対象データ(ax=val)が負の値の場合、符号出力を行うフラグ(bx)をオンにする
    58 0000022F 7D03                <1>         jge     .12E
    59 00000231 83CB02              <1>         or      bx, 0b0010  ;  bx |= 2. OR演算のためB2位置が1となる(0x0000 | 0x0010 = 0x0010)
    60                              <1> .12E:
    61                              <1> .10E:
    62                              <1> 
    63                              <1>         ; ------------------
    64                              <1>         ; 符号出力判定
    65                              <1>         ; ------------------
    66 00000234 F7C30200            <1>         test    bx, 0b0010      ; if(flag == 0x0010) {
    67 00000238 7412                <1> .20Q:   je      .20E            ; 
    68 0000023A 83F800              <1>         cmp     ax, 0           ;   if(num < 0) {
    69 0000023D 7D07                <1>         jge     .22F            ;
    70                              <1> 
    71                              <1>         ; 負の値の場合            ;
    72 0000023F F7D8                <1>         neg     ax              ; NEG(2の補数)命令によって、符号を反転: num *= -1
    73 00000241 C6042D              <1>         mov     [si], byte '-'  ; 変換先のバッファアドレス(si)の先頭に'-'を付与: *buff += '-'
    74 00000244 EB05                <1>         jmp     .22E            ;
    75                              <1> 
    76                              <1>         ; 正の値の場合
    77 00000246 C6042B              <1> .22F:   mov     [si], byte '+'  ; 変換先のバッファアドレス(si)の先頭に'+'を付与: *buff += '-'
    78 00000249 EB00                <1>         jmp     .22E
    79 0000024B 49                  <1> .22E:   dec     cx              ; 符号を付与した分、残りのバッファサイズ(cx=size)を減算
    80                              <1> .20E:
    81                              <1> 
    82                              <1>         ; ------------------
    83                              <1>         ; Ascii変換
    84                              <1>         ; ------------------
    85 0000024C 8B5E0A              <1>         mov     bx, [bp + 10]           ; BX = 基数を取得
    86                              <1> .30L:
    87 0000024F BA0000              <1>         mov     dx, 0                   ; 割り算の余りはdxに代入される。なので、事前に0初期化している。
    88 00000252 F7F3                <1>         div     bx                      ; 基数(bx)で割り算(div)を行う
    89                              <1> 
    90 00000254 89D6                <1>         mov     si, dx
    91 00000256 8A94[7E02]          <1>         mov     dl, byte [.ascii + si]  ; 割り算の余りから、Asciiテーブルを参照
    92                              <1> 
    93 0000025A 8815                <1>         mov     [di], dl                ; di(変換後のバッファアドレスの末尾)にAscii文字を設定
    94 0000025C 4F                  <1>         dec     di                      ; 末尾の１つ前が次のAscii文字設定先であるため、減算(dec)する
    95                              <1> 
    96                              <1>         ; 割り算対象の値は暗黙的にax(変換対象の数値)が使用される
    97                              <1>         ; loopnz命令により、残りのバッファサイズ(cx)か変換対象(az)が0になるまで、ループを繰り返す
    98 0000025D 83F800              <1>         cmp     ax, 0
    99 00000260 E0ED                <1>         loopnz  .30L
   100                              <1> .30E:
   101                              <1> 
   102                              <1>         ; ------------------
   103                              <1>         ; 空欄を埋める
   104                              <1>         ; ------------------
   105 00000262 83F900              <1>         cmp     cx, 0                   ; バッファサイズ(cx)が残っている場合に、空欄埋めを行う
   106 00000265 740D                <1> .40Q:   je      .40E
   107 00000267 B020                <1>         mov     al, ' '
   108 00000269 837E0C04            <1>         cmp     [bp + 12], word 0b0100
   109 0000026D 7502                <1> .42Q:   jne     .42E
   110 0000026F B030                <1>         mov     al, '0'
   111                              <1> .42E:
   112 00000271 FD                  <1>         std                             ; DF=0をセット
   113 00000272 F3AA                <1>         rep stosb                       ; rep命令を置くことで、cxレジスタが0になるまで、後続のstosb命令を繰り返す。その際、stosb命令実行後にcxレジスタの減算を行う。
   114                              <1> .40E:
   115                              <1> 
   116                              <1>     ; レジスタの復帰
   117 00000274 5F                  <1>     pop di
   118 00000275 5E                  <1>     pop si
   119 00000276 5A                  <1>     pop dx
   120 00000277 59                  <1>     pop cx
   121 00000278 5B                  <1>     pop bx
   122 00000279 58                  <1>     pop ax
   123                              <1> 
   124                              <1>     ; スタックフレームの破棄
   125 0000027A 89EC                <1>     mov sp, bp
   126 0000027C 5D                  <1>     pop bp
   127                              <1> 
   128 0000027D C3                  <1>     ret
   129                              <1> 
   130 0000027E 303132333435363738- <1> .ascii  db      "0123456789ABCDEF" ;変換デーブル
   130 00000287 39414243444546      <1>
    76                                  %include        "../modules/real/get_drive_params.s"
     1                              <1> ; --------------------------------------
     2                              <1> ; int get_drive_params(drive, no);
     3                              <1> ; @params drive :drive構造体のアドレス
     4                              <1> ; @params no    :対象となるドライブ番号
     5                              <1> ; @return       :成功(0以外) or 失敗(0)
     6                              <1> ; --------------------------------------
     7                              <1> 
     8                              <1> ; ****************
     9                              <1> ; レジスタ位置関係
    10                              <1> ; ***************
    11                              <1> ;   + 6 | no
    12                              <1> ;   + 4 | drive
    13                              <1> ;   + 2 | 戻り番地
    14                              <1> ; BP+ 0 | BP
    15                              <1> ; -----------------
    16                              <1> 
    17                              <1> get_drive_params:
    18                              <1>         ; スタックフレームの構築
    19 0000028E 55                  <1>         push    bp
    20 0000028F 89E5                <1>         mov     bp, sp
    21                              <1> 
    22                              <1>         ; レジスタの保存
    23 00000291 53                  <1>         push    bx
    24 00000292 51                  <1>         push    cx
    25 00000293 06                  <1>         push    es
    26 00000294 56                  <1>         push    si
    27 00000295 57                  <1>         push    di
    28                              <1> 
    29                              <1>         ; 処理の開始
    30 00000296 8B7604              <1>         mov     si, [bp + 4]        ; drive: drive構造体のアドレス
    31 00000299 B80000              <1>         mov     ax, 0
    32 0000029C 8EC0                <1>         mov     es, ax              ; ES=0
    33 0000029E 89C7                <1>         mov     di, ax              ; DI=0
    34                              <1> 
    35                              <1>         ; ドライブパラメタを読み込む: BIOS(0x13, 0x08)
    36                              <1>         ;  - 0x13: Disk Services           : FDD、HDD、ROMディスク、RFDディスクなどにアクセスする
    37                              <1>         ;  - 0x08: Read Drive Parameters   : ドライブパラメータを読み込み
    38                              <1>         ;    (Ref: http://softwaretechnique.jp/OS_Development/Tips/Bios_Services/disk_services.html)
    39                              <1>         ;  - 取得したドライブパラメタは、CH, CL, DH, DLレジスタに設定される。
    40 000002A0 B408                <1>         mov     ah, 8
    41 000002A2 8A14                <1>         mov     dl, [si + drive.no] ; DL = ドライブ番号
    42 000002A4 CD13                <1>         int     0x13                ; BIOS(0x13, AH=0x08)
    43 000002A6 721B                <1> .10Q:   jc      .10F
    44                              <1> .10T:
    45                              <1>         ; セクタ数(AX)を取得
    46                              <1>         ; - セクタ数はCLの下位6ビットに割り当てられている(上位2ビットはシリンダ数が割り当てられている)
    47                              <1>         ; - ALはAXの下位８ビットであるため、ALに代入してもAXで使用できる
    48                              <1>         ; - セクタ数の取得は、ALと0x3FのAND演算による下位6ビット抽出によって行う
    49 000002A8 88C8                <1>         mov     al, cl
    50 000002AA 83E03F              <1>         and     ax, 0x3F
    51                              <1> 
    52                              <1>         ; シリンダ数の取得
    53                              <1>         ; - 読み込んだシリンダはCHとCLの上位2ビットに割り当てられている(以下の括弧で囲われているビットが対象)
    54                              <1>         ;   CH                           CL
    55                              <1>         ;   [(7),(6),(5),(4),(3),(2),(1)][(*7),(*6),5,4,3,2,1]
    56                              <1>         ;
    57                              <1>         ; - シリンダ取得では、上のCH,CL内のデータを以下の並びにする
    58                              <1>         ;   [(*7),(*6),(7),(6),(5),(4),(3),(2),(1)]
    59 000002AD C0E906              <1>         shr     cl, 6               ; CLを6ビット分の右シフト
    60 000002B0 C1C908              <1>         ror     cx, 8               ; CX(CH+CL)を8ビット分の右回転
    61 000002B3 41                  <1>         inc     cx                  ; シリンダ数は0始まりであるため、1加算する
    62                              <1> 
    63                              <1>         ; ヘッド数の取得
    64                              <1>         ; - ヘッド数は、DHに割り当てられている
    65 000002B4 0FB6DE              <1>         movzx   bx, dh              ; movzx命令で上位1バイト追加して取得する
    66 000002B7 43                  <1>         inc     bx                  ; ヘッド数は0始まりであるため、1加算する
    67                              <1> 
    68                              <1>         ; 取得したドライブパラメタを、引数のdrive構造体に設定
    69 000002B8 894C02              <1>         mov [si + drive.cyln], cx
    70 000002BB 895C04              <1>         mov [si + drive.head], bx
    71 000002BE 894406              <1>         mov [si + drive.sect], ax
    72                              <1> 
    73 000002C1 EB03                <1>         jmp .10E
    74                              <1> .10F:
    75                              <1>         ; 読み込み失敗した場合、戻り値を0(=失敗)に設定
    76 000002C3 B80000              <1>         mov     ax, 0
    77                              <1> .10E:
    78                              <1>         ; レジスタの復帰
    79 000002C6 5F                  <1>         pop di
    80 000002C7 5E                  <1>         pop si
    81 000002C8 07                  <1>         pop es
    82 000002C9 59                  <1>         pop cx
    83 000002CA 5B                  <1>         pop bx
    84                              <1> 
    85                              <1>         ; スタックフレームの破棄
    86 000002CB 89EC                <1>         mov sp, bp
    87 000002CD 5D                  <1>         pop bp
    88                              <1> 
    89 000002CE C3                  <1>         ret
    77                                  %include        "../modules/real/get_font_adr.s"
     1                              <1> ; --------------------------------------
     2                              <1> ; int get_font_adr(adr);
     3                              <1> ; @params adr   : フォントアドレスの格納位置
     4                              <1> ; @return       : なし
     5                              <1> ; --------------------------------------
     6                              <1> 
     7                              <1> ; ****************
     8                              <1> ; レジスタ位置関係
     9                              <1> ; ***************
    10                              <1> ;   + 4 | adr
    11                              <1> ;   + 2 | 戻り番地
    12                              <1> ; BP+ 0 | BP
    13                              <1> ; -----------------
    14                              <1> 
    15                              <1> get_font_adr:
    16                              <1>         ; スタックフレームの構築
    17 000002CF 55                  <1>         push bp
    18 000002D0 89E5                <1>         mov bp, sp
    19                              <1> 
    20                              <1>         ; レジスタの保存
    21 000002D2 50                  <1>         push ax
    22 000002D3 53                  <1>         push bx
    23 000002D4 56                  <1>         push si
    24 000002D5 06                  <1>         push es
    25 000002D6 55                  <1>         push bp
    26                              <1> 
    27                              <1>         ; 引数を取得
    28 000002D7 8B7604              <1>         mov si, [bp + 4]
    29                              <1> 
    30                              <1>         ; フォントアドレスの取得
    31                              <1>         ; - AXとBHに指定の値を設定することで、フォントアドレスが取得できる
    32                              <1>         ;   Ref: http://hp.vector.co.jp/authors/VA003720/lpproj/int10h/i101130.htm
    33 000002DA B83011              <1>         mov ax, 0x1130  ; 0x1130:フォントアドレス取得
    34 000002DD B706                <1>         mov bh, 0x06    ; 0x06  :8x16ドットサイズ 
    35 000002DF CD10                <1>         int 10h
    36                              <1> 
    37                              <1>         ; フォントアドレスを保存
    38 000002E1 8C04                <1>         mov [si + 0], es    ; セグメント
    39 000002E3 896C02              <1>         mov [si + 2], bp    ; オフセット
    40                              <1> 
    41                              <1>         ; レジスタの復帰
    42 000002E6 5D                  <1>         pop bp
    43 000002E7 07                  <1>         pop es
    44 000002E8 5E                  <1>         pop si
    45 000002E9 5B                  <1>         pop bx
    46 000002EA 58                  <1>         pop ax
    47                              <1> 
    48                              <1>         ; スタックフレームの破棄
    49 000002EB 89EC                <1>         mov sp, bp
    50 000002ED 5D                  <1>         pop bp
    51                              <1> 
    52 000002EE C3                  <1>         ret
    78                                  %include        "../modules/real/get_mem_info.s"
     1                              <1> ; --------------------------------------
     2                              <1> ; void get_mem_info();
     3                              <1> ; @return       : なし
     4                              <1> ; --------------------------------------
     5                              <1> 
     6                              <1> ; ****************
     7                              <1> ; レジスタ位置関係
     8                              <1> ; ***************
     9                              <1> ;   + 2 | 戻り番地
    10                              <1> ; BP+ 0 | BP
    11                              <1> ; -----------------
    12                              <1> 
    13                              <1> get_mem_info:
    14                              <1>         ; レジスタ保存
    15                              <1>         ; eax: 32bit(ax: 16bit, rax: 64bit)
    16 000002EF 6650                <1>         push eax
    17 000002F1 6653                <1>         push ebx
    18 000002F3 6651                <1>         push ecx
    19 000002F5 6652                <1>         push edx
    20 000002F7 56                  <1>         push si
    21 000002F8 57                  <1>         push di
    22 000002F9 55                  <1>         push bp
    23                              <1> 
    24 000002FA 00<rept>            <1> ALIGN 4, db 0
    25 000002FC 00<rept>            <1> .b0:    times E820_RECORD_SIZE db 0
    26 00000310 68[A403]E8B8FD83C4- <1>         cdecl puts, .s0
    26 00000318 02                  <1>
    27                              <1>         
    28                              <1>         ; メモリ情報取得開始
    29 00000319 BD0000              <1>         mov bp, 0
    30 0000031C 66BB00000000        <1>         mov ebx, 0
    31                              <1> .10L:
    32                              <1>         ; メモリ情報を取得するBIOSコール
    33 00000322 66B820E80000        <1>         mov eax, 0x0000E820         ; EAX   = 0xE820(要求コマンド)
    34                              <1>                                     ; EBX   = インデックス(0)
    35 00000328 66B914000000        <1>         mov ecx, E820_RECORD_SIZE   ; ECX   = 要求バイト数
    36 0000032E 66BA50414D53        <1>         mov edx, 'PAMS'             ; EDX   = SMAP
    37 00000334 BF[FC02]            <1>         mov di, .b0                 ; ES:DI = バッファ
    38 00000337 CD15                <1>         int 0x15                    ; BIOS(0x15, 0xE820)
    39                              <1> 
    40                              <1>         ; メモリ情報取得が未対応のBIOSの場合(EAXにSMAPが設定されないはず)
    41 00000339 663D50414D53        <1>         cmp eax, 'PAMS'
    42 0000033F 7402                <1>         je  .12E
    43 00000341 EB4C                <1>         jmp .10E
    44                              <1> .12E:
    45                              <1>         ; BIOSコールに失敗した場合(エラー時はCFで判断可能)
    46 00000343 7302                <1>         jnc .14E
    47 00000345 EB48                <1>         jmp .10E
    48                              <1> .14E:
    49                              <1>         ; 1コード分のメモリ情報を表示
    50 00000347 57E8E40083C402      <1>         cdecl put_mem_info, di
    51                              <1> 
    52                              <1>         ; ACPI dataのアドレスを取得
    53 0000034E 668B4510            <1>         mov eax, [di + 16]          ; EAX: レコードタイプ
    54 00000352 6683F803            <1>         cmp eax, 3                  ; EAX = 3(ACPI data)の場合
    55 00000356 750F                <1>         jne .15E
    56                              <1> 
    57 00000358 668B05              <1>         mov eax, [di + 0]           ; メモリ領域のBASEアドレスの保存
    58 0000035B 66A3[0402]          <1>         mov [ACPI_DATA.adr], eax
    59                              <1> 
    60 0000035F 668B4508            <1>         mov eax, [di + 8]           ; メモリ領域のサイズの保存
    61 00000363 66A3[0802]          <1>         mov [ACPI_DATA.len], eax
    62                              <1> .15E:
    63 00000367 6683FB00            <1>         cmp ebx, 0
    64 0000036B 741C                <1>         jz  .16E
    65                              <1>         
    66 0000036D 45                  <1>         inc bp
    67 0000036E 83E507              <1>         and bp, 0x07
    68 00000371 7516                <1>         jnz .16E
    69                              <1>         
    70 00000373 68[1704]E855FD83C4- <1>         cdecl puts, .s2
    70 0000037B 02                  <1>
    71                              <1> 
    72 0000037C B410                <1>         mov ah, 0x10
    73 0000037E CD16                <1>         int 0x16
    74                              <1>         
    75 00000380 68[2204]E848FD83C4- <1>         cdecl puts, .s3
    75 00000388 02                  <1>
    76                              <1> .16E:
    77 00000389 6683FB00            <1>         cmp ebx, 0
    78 0000038D 7593                <1>         jne .10L
    79                              <1> .10E:
    80 0000038F 68[E703]E839FD83C4- <1>         cdecl puts, .s1
    80 00000397 02                  <1>
    81                              <1>         
    82                              <1> ; レジスタ復帰
    83 00000398 5D                  <1>         pop bp
    84 00000399 5F                  <1>         pop di
    85 0000039A 5E                  <1>         pop si
    86 0000039B 665A                <1>         pop edx
    87 0000039D 6659                <1>         pop ecx
    88 0000039F 665B                <1>         pop ebx
    89 000003A1 6658                <1>         pop eax
    90                              <1> 
    91 000003A3 C3                  <1>         ret
    92                              <1> 
    93                              <1> ; データ定義
    94 000003A4 2045383230204D656D- <1> .s0:	db " E820 Memory Map:", 0x0A, 0x0D
    94 000003AD 6F7279204D61703A0A- <1>
    94 000003B6 0D                  <1>
    95 000003B7 20426173655F5F5F5F- <1> 	db " Base_____________ Length___________ Type____", 0x0A, 0x0D, 0
    95 000003C0 5F5F5F5F5F5F5F5F5F- <1>
    95 000003C9 204C656E6774685F5F- <1>
    95 000003D2 5F5F5F5F5F5F5F5F5F- <1>
    95 000003DB 20547970655F5F5F5F- <1>
    95 000003E4 0A0D00              <1>
    96 000003E7 202D2D2D2D2D2D2D2D- <1> .s1:	db " ----------------- ----------------- --------", 0x0A, 0x0D, 0
    96 000003F0 2D2D2D2D2D2D2D2D2D- <1>
    96 000003F9 202D2D2D2D2D2D2D2D- <1>
    96 00000402 2D2D2D2D2D2D2D2D2D- <1>
    96 0000040B 202D2D2D2D2D2D2D2D- <1>
    96 00000414 0A0D00              <1>
    97 00000417 203C6D6F72652E2E2E- <1> .s2:    db " <more...>", 0
    97 00000420 3E00                <1>
    98 00000422 0D2020202020202020- <1> .s3:    db 0x0D, "          ", 0x0D, 0
    98 0000042B 20200D00            <1>
    79                                  %include        "../modules/real/put_mem_info.s"
     1                              <1> ; --------------------------------------
     2                              <1> ; int put_mem_info(adr);
     3                              <1> ; @params adr   :バッファアドレス
     4                              <1> ; @return       :成功(0以外) or 失敗(0)
     5                              <1> ; --------------------------------------
     6                              <1> 
     7                              <1> ; ****************
     8                              <1> ; レジスタ位置関係
     9                              <1> ; ***************
    10                              <1> ;   + 4 | adr
    11                              <1> ;   + 2 | 戻り番地
    12                              <1> ; BP+ 0 | BP
    13                              <1> ; -----------------
    14                              <1> 
    15                              <1> put_mem_info:
    16                              <1>     ; スタックフレームの構築
    17 0000042F 55                  <1>     push bp
    18 00000430 89E5                <1>     mov  bp, sp
    19                              <1> 
    20                              <1>     ; レジスタの保存
    21 00000432 53                  <1>     push bx
    22 00000433 56                  <1>     push si
    23                              <1> 
    24                              <1>     ; 引数の取得
    25 00000434 8B7604              <1>     mov si, [bp + 4]
    26                              <1> 
    27                              <1>     ; Baseアドレス(64bit)
    28 00000437 6A046A106A0468-     <1>     cdecl itoa, word [si + 6], .p2 + 0, 4, 16, 0b0100
    28 0000043E [0E05]FF7406E8C6FD- <1>
    28 00000446 83C40A              <1>
    29 00000449 6A046A106A0468-     <1>     cdecl itoa, word [si + 4], .p2 + 4, 4, 16, 0b0100
    29 00000450 [1205]FF7404E8B4FD- <1>
    29 00000458 83C40A              <1>
    30 0000045B 6A046A106A0468-     <1>     cdecl itoa, word [si + 2], .p3 + 0, 4, 16, 0b0100
    30 00000462 [1705]FF7402E8A2FD- <1>
    30 0000046A 83C40A              <1>
    31 0000046D 6A046A106A0468-     <1>     cdecl itoa, word [si + 0], .p3 + 4, 4, 16, 0b0100
    31 00000474 [1B05]FF34E891FD83- <1>
    31 0000047C C40A                <1>
    32                              <1> 
    33                              <1>     ; データ長(64bit)
    34 0000047E 6A046A106A0468-     <1>     cdecl itoa, word [si + 14], .p4 + 0, 4, 16, 0b0100
    34 00000485 [2005]FF740EE87FFD- <1>
    34 0000048D 83C40A              <1>
    35 00000490 6A046A106A0468-     <1>     cdecl itoa, word [si + 12], .p4 + 4, 4, 16, 0b0100
    35 00000497 [2405]FF740CE86DFD- <1>
    35 0000049F 83C40A              <1>
    36 000004A2 6A046A106A0468-     <1>     cdecl itoa, word [si + 10], .p5 + 0, 4, 16, 0b0100
    36 000004A9 [2905]FF740AE85BFD- <1>
    36 000004B1 83C40A              <1>
    37 000004B4 6A046A106A0468-     <1>     cdecl itoa, word [si +  8], .p5 + 4, 4, 16, 0b0100
    37 000004BB [2D05]FF7408E849FD- <1>
    37 000004C3 83C40A              <1>
    38                              <1> 
    39                              <1>     ; Type(32bit)
    40 000004C6 6A046A106A0468-     <1>     cdecl itoa, word [si + 18], .p6 + 0, 4, 16, 0b0100
    40 000004CD [3205]FF7412E837FD- <1>
    40 000004D5 83C40A              <1>
    41 000004D8 6A046A106A0468-     <1>     cdecl itoa, word [si + 16], .p6 + 4, 4, 16, 0b0100
    41 000004DF [3605]FF7410E825FD- <1>
    41 000004E7 83C40A              <1>
    42                              <1> 
    43 000004EA 68[0D05]E8DEFB83C4- <1>     cdecl puts, .s1
    43 000004F2 02                  <1>
    44                              <1> 
    45                              <1>     ; Typeを文字列として表示
    46 000004F3 8B5C10              <1>     mov bx, [si + 16]
    47 000004F6 83E307              <1>     and bx, 0x07            ; 0010 & 0111 = 0010
    48 000004F9 D1E3                <1>     shl bx, 1               ; 0010 -> 0100(=4)
    49 000004FB 81C3[8905]          <1>     add bx, .t0             ; レコード情報テーブルの先頭アドレスを加算 -> 指定レコードの情報が取得できる
    50 000004FF FF37E8CAFB83C402    <1>     cdecl puts, word [bx]
    51                              <1> 
    52                              <1>     ; レジスタの復帰
    53 00000507 5E                  <1>     pop si
    54 00000508 5B                  <1>     pop bx
    55                              <1> 
    56                              <1>     ; スタックフレームの破棄
    57 00000509 89EC                <1>     mov sp, bp
    58 0000050B 5D                  <1>     pop bp
    59                              <1> 
    60 0000050C C3                  <1>     ret
    61                              <1> 
    62                              <1> ; 定数定義
    63 0000050D 20                  <1> .s1:    db " "
    64 0000050E 5A5A5A5A5A5A5A5A5F  <1> .p2:    db "ZZZZZZZZ_"
    65 00000517 5A5A5A5A5A5A5A5A20  <1> .p3:    db "ZZZZZZZZ "
    66 00000520 5A5A5A5A5A5A5A5A5F  <1> .p4:    db "ZZZZZZZZ_"
    67 00000529 5A5A5A5A5A5A5A5A20  <1> .p5:    db "ZZZZZZZZ "
    68 00000532 5A5A5A5A5A5A5A5A00  <1> .p6:    db "ZZZZZZZZ", 0
    69                              <1> 
    70 0000053B 28556E6B6E6F776E29- <1> .s4:    db "(Unknown)", 0x0A, 0x0D, 0
    70 00000544 0A0D00              <1>
    71 00000547 28757361626C65290A- <1> .s5:    db "(usable)", 0x0A, 0x0D, 0
    71 00000550 0D00                <1>
    72 00000552 287265736572766564- <1> .s6:    db "(reserved)", 0x0A, 0x0D, 0
    72 0000055B 290A0D00            <1>
    73 0000055F 284143504920646174- <1> .s7:    db "(ACPI data)", 0x0A, 0x0D, 0
    73 00000568 61290A0D00          <1>
    74 0000056D 2841435049204E5653- <1> .s8:    db "(ACPI NVS)", 0x0A, 0x0D, 0
    74 00000576 290A0D00            <1>
    75 0000057A 28626164206D656D6F- <1> .s9:    db "(bad memory)", 0x0A, 0x0D, 0
    75 00000583 7279290A0D00        <1>
    76                              <1> 
    77                              <1>         ; dw(data double byte): 2バイトデータとして定義する
    78                              <1>         ; 要素間のアドレス差は2byteなので、+2すると次要素になる
    79 00000589 [3B05][4705][5205]- <1> .t0:    dw .s4, .s5, .s6, .s7, .s8, .s9, .s4, .s4
    79 0000058F [5F05][6D05][7A05]- <1>
    79 00000595 [3B05][3B05]        <1>
    80                                  %include        "../modules/real/kbc.s"
     1                              <1> ; --------------------------------------
     2                              <1> ; void KBC_data_write();
     3                              <1> ; KBCデータを書き込む
     4                              <1> ;
     5                              <1> ; @return       : 成功(0以外), 失敗(0)
     6                              <1> ; @param  data  : 書き込みデータ
     7                              <1> ; --------------------------------------
     8                              <1> 
     9                              <1> ; ****************
    10                              <1> ; レジスタ位置関係
    11                              <1> ; ***************
    12                              <1> ;   + 4 | data
    13                              <1> ;   + 2 | 戻り番地
    14                              <1> ; BP+ 0 | BP
    15                              <1> ; -----------------
    16                              <1> 
    17                              <1> KBC_data_write:
    18                              <1>     ; スタックフレームの構築
    19 00000599 55                  <1>     push bp
    20 0000059A 89E5                <1>     mov bp, sp
    21                              <1> 
    22                              <1>     ; レジスタの保存
    23 0000059C 51                  <1>     push cx
    24                              <1> 
    25                              <1>     ; KBCバッファへの書き込み開始
    26 0000059D B90000              <1>     mov cx, 0
    27                              <1> 
    28                              <1> .10L:
    29                              <1>     ; KBCバッファへの書き込み可否を判定
    30 000005A0 E464                <1>     in al, 0x64     ; KBCステータスの取得
    31 000005A2 A802                <1>     test al, 0x02   ; AL & 0x02 // 書き込み可能であるかチェック
    32 000005A4 E0FA                <1>     loopnz  .10L    ; CXレジスタを減算し、0になったら次へ進む。そうではない場合は指定ラベルへ移動
    33                              <1>                     ; ????
    34 000005A6 83F900              <1>     cmp cx, 0       ; タイムアウト判定    
    35 000005A9 7405                <1>     jz  .20E
    36                              <1> 
    37 000005AB 8A4604              <1>     mov al, [bp + 4]
    38 000005AE E660                <1>     out 0x60, al    ; 指定データポート(0x60)に対して、データを出力する
    39                              <1> .20E:
    40 000005B0 89C8                <1>     mov ax, cx      ; return CX; CXレジスタが0以外の場合は書き込みされている
    41                              <1> 
    42                              <1>     ; レジスタの復帰
    43 000005B2 59                  <1>     pop cx
    44                              <1> 
    45                              <1>     ; スタックフレームの破棄
    46 000005B3 89EC                <1>     mov sp, bp
    47 000005B5 5D                  <1>     pop bp
    48                              <1> 
    49 000005B6 C3                  <1>     ret
    50                              <1> 
    51                              <1> ; --------------------------------------
    52                              <1> ; void KBC_data_read();
    53                              <1> ; KBCデータを読み込む
    54                              <1> ;
    55                              <1> ; @return       : 成功(0以外), 失敗(0)
    56                              <1> ; @param  data  : 読み込みデータのアドレス
    57                              <1> ; --------------------------------------
    58                              <1> 
    59                              <1> ; ****************
    60                              <1> ; レジスタ位置関係
    61                              <1> ; ***************
    62                              <1> ;   + 4 | data
    63                              <1> ;   + 2 | 戻り番地
    64                              <1> ; BP+ 0 | BP
    65                              <1> ; -----------------
    66                              <1> 
    67                              <1> KBC_data_read:
    68                              <1>     ; スタックフレームの構築
    69 000005B7 55                  <1>     push bp
    70 000005B8 89E5                <1>     mov bp, sp
    71                              <1> 
    72                              <1>     ; レジスタの保存
    73 000005BA 51                  <1>     push cx
    74                              <1> 
    75                              <1>     ; KBCバッファ読み込み開始
    76 000005BB B90000              <1>     mov cx, 0
    77                              <1> 
    78                              <1> .10L:
    79                              <1>     ; KBCバッファへの読み込み可否を判定
    80 000005BE E464                <1>     in al, 0x64         ; KBCステータスの取得
    81 000005C0 A801                <1>     test al, 0x01       ; AL & 0x01 // 読み込み可能であるかチェック
    82 000005C2 E1FA                <1>     loopz  .10L         ; CXレジスタを減算し、0になったら次へ進む。そうではない場合は指定ラベルへ移動
    83                              <1>                         ; ????
    84 000005C4 83F900              <1>     cmp cx, 0           ; タイムアウト判定    
    85 000005C7 7409                <1>     jz  .20E
    86                              <1>     
    87                              <1>     ; データポート(0x60)に対して、データ取得を実行
    88 000005C9 B400                <1>     mov ah, 0x00
    89 000005CB E460                <1>     in al, 0x60
    90                              <1> 
    91                              <1>     ; 取得データを読み込みデータバッファへ設定(data)
    92 000005CD 8B7E04              <1>     mov di, [bp + 4]
    93 000005D0 8905                <1>     mov [di + 0], ax
    94                              <1> .20E:
    95 000005D2 89C8                <1>     mov ax, cx          ; return CX; CXレジスタが0以外の場合は書き込みされている
    96                              <1> 
    97                              <1>     ; レジスタの復帰
    98 000005D4 59                  <1>     pop cx
    99                              <1> 
   100                              <1>     ; スタックフレームの破棄
   101 000005D5 89EC                <1>     mov sp, bp
   102 000005D7 5D                  <1>     pop bp
   103                              <1> 
   104 000005D8 C3                  <1>     ret
   105                              <1> 
   106                              <1> ; --------------------------------------
   107                              <1> ; void KBC_cmd_write(cmd);
   108                              <1> ; KBCコマンドを書き込む
   109                              <1> ;
   110                              <1> ; @return       : 成功(0以外), 失敗(0)
   111                              <1> ; @param  cmd   : 書き込みコマンド
   112                              <1> ; --------------------------------------
   113                              <1> 
   114                              <1> ; ****************
   115                              <1> ; レジスタ位置関係
   116                              <1> ; ***************
   117                              <1> ;   + 4 | cmd
   118                              <1> ;   + 2 | 戻り番地
   119                              <1> ; BP+ 0 | BP
   120                              <1> ; -----------------
   121                              <1> 
   122                              <1> KBC_cmd_write:
   123                              <1>     ; スタックフレームの構築
   124 000005D9 55                  <1>     push bp
   125 000005DA 89E5                <1>     mov bp, sp
   126                              <1> 
   127                              <1>     ; レジスタの保存
   128 000005DC 51                  <1>     push cx
   129                              <1> 
   130                              <1>     ; KBCバッファへの書き込み開始
   131 000005DD B90000              <1>     mov cx, 0
   132                              <1> 
   133                              <1> .10L:
   134                              <1>     ; KBCバッファへの書き込み可否を判定
   135 000005E0 E464                <1>     in al, 0x64     ; KBCステータスの取得
   136 000005E2 A802                <1>     test al, 0x02   ; AL & 0x02 // 書き込み可能であるかチェック
   137 000005E4 E0FA                <1>     loopnz  .10L    ; CXレジスタを減算し、0になったら次へ進む。そうではない場合は指定ラベルへ移動
   138                              <1>                     ; ????
   139 000005E6 83F900              <1>     cmp cx, 0       ; タイムアウト判定    
   140 000005E9 7405                <1>     jz  .20E
   141                              <1> 
   142                              <1>     ; コマンド/ステータス用のデータポート(0x64)に対して、コマンドを出力する
   143 000005EB 8A4604              <1>     mov al, [bp + 4]
   144 000005EE E664                <1>     out 0x64, al
   145                              <1> .20E:
   146 000005F0 89C8                <1>     mov ax, cx      ; return CX; CXレジスタが0以外の場合は書き込みされている
   147                              <1> 
   148                              <1>     ; レジスタの復帰
   149 000005F2 59                  <1>     pop cx
   150                              <1> 
   151                              <1>     ; スタックフレームの破棄
   152 000005F3 89EC                <1>     mov sp, bp
   153 000005F5 5D                  <1>     pop bp
   154                              <1> 
   155 000005F6 C3                  <1>     ret
    81                                  %include        "../modules/real/lba_chs.s"
     1                              <1> ; --------------------------------------
     2                              <1> ; void lba_chs(drive, drv_chs, lba);
     3                              <1> ; セクタ指定について、LBA方式からCHS方式へ変換する関数
     4                              <1> ;  - LBA: セクタ位置に通し番号をつけることで、位置を特定する方法
     5                              <1> ;  - CHS: シリンダ、ヘッド、セクタによって、位置を特定する方法
     6                              <1> ;
     7                              <1> ; @return         : 成功(0以外), 失敗(0)
     8                              <1> ; @param  drive   : Drive構造体のアドレス(Driveパラメタ)
     9                              <1> ; @param  drv_chs : Drive構造体のアドレス(変更後のシリンダ番号、ヘッド番号、セクタ番号を保存)
    10                              <1> ; @param  lba     : LBA
    11                              <1> ; --------------------------------------
    12                              <1> 
    13                              <1> ; ****************
    14                              <1> ; レジスタ位置関係
    15                              <1> ; ***************
    16                              <1> ;   + 8 | lba
    17                              <1> ;   + 6 | drv_chs
    18                              <1> ;   + 4 | drive
    19                              <1> ;   + 2 | 戻り番地
    20                              <1> ; BP+ 0 | BP
    21                              <1> ; -----------------
    22                              <1> 
    23                              <1> lba_chs:
    24                              <1>     ; スタックフレームの構築
    25 000005F7 55                  <1>     push bp
    26 000005F8 89E5                <1>     mov bp, sp
    27                              <1> 
    28                              <1>     ; レジスタの保存
    29 000005FA 50                  <1>     push ax
    30 000005FB 53                  <1>     push bx
    31 000005FC 52                  <1>     push dx
    32 000005FD 56                  <1>     push si
    33 000005FE 57                  <1>     push di
    34                              <1>     
    35 000005FF 8B7604              <1>     mov si, [bp + 4]
    36 00000602 8B7E06              <1>     mov di, [bp + 6]
    37                              <1> 
    38                              <1>     ; シリンダあたりのセクタ数を計算
    39 00000605 8A4404              <1>     mov al, [si + drive.head]   ; AL: 最大ヘッド数
    40 00000608 F66406              <1>     mul byte [si + drive.sect] ; AX: 最大ヘッド数(AL)×最大セクタ数
    41 0000060B 89C3                <1>     mov bx, ax                  ; BX: シリンダあたりのセクタ数
    42                              <1> 
    43                              <1>     ; 指定されたLBAのシリンダ番号を計算
    44 0000060D BA0000              <1>     mov dx, 0                   ; DX = LBA(上位2バイト)
    45 00000610 8B4608              <1>     mov ax, [bp + 8]            ; AX = LBA(下位2バイト)
    46 00000613 F7F3                <1>     div bx                      ; DX = DX~AX % BX(余り)
    47                              <1>                                 ; AX = DX~AX / BX(割り算結果) = シリンダ番号
    48 00000615 894502              <1>     mov [di + drive.cyln], ax   ; シリンダ番号をdrive構造体へ保存
    49                              <1> 
    50                              <1>     ; セクタ番号とヘッド番号を計算
    51 00000618 89D0                <1>     mov ax, dx                  ; AX = BX(余り)
    52 0000061A F67406              <1>     div byte [si + drive.sect]  ; AH = AX % 最大セクタ数(余り) = セクタ番号 
    53                              <1>                                 ; AL = AX / 最大セクタ数(割り算結果) = ヘッド番号
    54                              <1>     
    55                              <1>     ; セクタ番号の保存
    56 0000061D 0FB6D4              <1>     movzx dx, ah                ; セクタ番号を2バイト拡張してDXへ保存
    57 00000620 42                  <1>     inc dx                      ; セクタ番号は1始まりなので+1
    58                              <1> 
    59                              <1>     ; ヘッド番号の保存
    60 00000621 B400                <1>     mov ah, 0x00                ; AHを0指定し、AX(AH+AL)で2バイトのヘッド番号データとして扱う
    61                              <1> 
    62 00000623 894504              <1>     mov [di + drive.head], ax
    63 00000626 895506              <1>     mov [di + drive.sect], dx
    64                              <1> 
    65                              <1>     ; レジスタの復帰
    66 00000629 5F                  <1>     pop di
    67 0000062A 5E                  <1>     pop si
    68 0000062B 5A                  <1>     pop dx
    69 0000062C 5B                  <1>     pop bx
    70 0000062D 58                  <1>     pop ax
    71                              <1> 
    72                              <1>     ; スタックフレームの破棄
    73 0000062E 89EC                <1>     mov sp, bp
    74 00000630 5D                  <1>     pop bp
    75                              <1> 
    76 00000631 C3                  <1>     ret
    82                                  %include        "../modules/real/read_lba.s"
     1                              <1> ; --------------------------------------
     2                              <1> ; void read_lba(drive, lba, sect, dst);
     3                              <1> ; LBAでのセクタ読み出しを行う。内部的には、LBA->CHS方式へ変換している
     4                              <1> ;  - LBA: セクタ位置に通し番号をつけることで、位置を特定する方法
     5                              <1> ;  - CHS: シリンダ、ヘッド、セクタによって、位置を特定する方法
     6                              <1> ;
     7                              <1> ; @return         : 読み込んだセクタ数
     8                              <1> ; @param  drive   : drive構造体アドレス(ドライブパラメタ)
     9                              <1> ; @param  lba     : LBA
    10                              <1> ; @param  sect    : 読み出しセクタ数
    11                              <1> ; @param  dst     : 読み出し先アドレス
    12                              <1> ; --------------------------------------
    13                              <1> 
    14                              <1> ; ****************
    15                              <1> ; レジスタ位置関係
    16                              <1> ; ***************
    17                              <1> ;   + 10 | dst
    18                              <1> ;   + 8  | sect
    19                              <1> ;   + 6  | lba
    20                              <1> ;   + 4  | drive
    21                              <1> ;   + 2  | 戻り番地
    22                              <1> ; BP+ 0  | BP
    23                              <1> ; -----------------
    24                              <1> 
    25                              <1> read_lba:
    26                              <1>     ; スタックフレームの構築
    27 00000632 55                  <1>     push bp
    28 00000633 89E5                <1>     mov bp, sp
    29                              <1> 
    30                              <1>     ; レジスタの保存
    31 00000635 56                  <1>     push si
    32                              <1>     
    33                              <1>     ; LBA -> CHS変換
    34 00000636 8B7604              <1>     mov si, [bp + 4] ; ドライブ情報
    35 00000639 8B4606              <1>     mov ax, [bp + 6] ; LBA
    36 0000063C 5068[6006]56E8B3FF- <1>     cdecl lba_chs, si, .chs, ax
    36 00000644 83C406              <1>
    37                              <1> 
    38                              <1>     ; ドライブ番号コピー
    39 00000647 8A04                <1>     mov al, [si + drive.no]
    40 00000649 A2[6006]            <1>     mov [.chs + drive.no], al
    41                              <1> 
    42                              <1>     ; セクタ読み出し
    43                              <1>     ; AX = read_chs(.chs, セクタ数, 読み出し先アドレス)
    44 0000064C FF760AFF760868-     <1>     cdecl read_chs, .chs, word[bp + 8], word[bp + 10]
    44 00000653 [6006]E8D4FA83C406  <1>
    45                              <1> 
    46                              <1>     ; レジスタの復帰
    47 0000065B 5E                  <1>     pop si
    48                              <1> 
    49                              <1>     ; スタックフレームの破棄
    50 0000065C 89EC                <1>     mov sp, bp
    51 0000065E 5D                  <1>     pop bp
    52                              <1> 
    53 0000065F C3                  <1>     ret
    54                              <1> 
    55                              <1> ALIGN 2
    56 00000660 00<rept>            <1> .chs: times drive_size db 0
    83                                  
    84                                  stage_2:
    85 00000668 68[E206]E860FA83C4-             cdecl   puts, .s0
    85 00000670 02                 
    86                                  
    87                                          ; ドライブ情報を取得
    88 00000671 68[C600]E817FC83C4-             cdecl   get_drive_params, BOOT
    88 00000679 02                 
    89 0000067A 83F800                          cmp     ax, 0
    90 0000067D 750C                    .10Q:   jne     .10E
    91 0000067F 68[1907]E849FA83C4-     .10T:   cdecl   puts, .e0
    91 00000687 02                 
    92 00000688 E862FA                          call    reboot
    93                                  .10E:
    94                                  
    95                                          ; ドライブ情報を表示
    96                                          ; 以下が表示される
    97                                          ; Drive:0x80, C:0x0014, H:0x02, D:0x10
    98                                          ; ドライブ番号:128, シリンダ数:20, ヘッド数:2, セクタ数:16
    99 0000068B A1[C600]                        mov     ax, [BOOT + drive.no]
   100 0000068E 6A046A106A0268-                 cdecl   itoa, ax, .p1, 2, 16, 0b0100
   100 00000695 [FA06]50E871FB83C4-
   100 0000069D 0A                 
   101 0000069E A1[C800]                        mov     ax, [BOOT + drive.cyln]
   102 000006A1 6A046A106A0468-                 cdecl   itoa, ax, .p2, 4, 16, 0b0100
   102 000006A8 [0207]50E85EFB83C4-
   102 000006B0 0A                 
   103 000006B1 A1[CA00]                        mov     ax, [BOOT + drive.head]
   104 000006B4 6A046A106A0268-                 cdecl   itoa, ax, .p3, 2, 16, 0b0100
   104 000006BB [0C07]50E84BFB83C4-
   104 000006C3 0A                 
   105 000006C4 A1[CC00]                        mov     ax, [BOOT + drive.sect]
   106 000006C7 6A046A106A0268-                 cdecl   itoa, ax, .p4, 2, 16, 0b0100
   106 000006CE [1407]50E838FB83C4-
   106 000006D6 0A                 
   107 000006D7 68[F106]E8F1F983C4-             cdecl   puts, .s1
   107 000006DF 02                 
   108                                  
   109                                          ; 処理の終了
   110 000006E0 EB53                            jmp     stage_3rd
   111                                  
   112                                  ; データ定義
   113 000006E2 326E64207374616765-     .s0     db      "2nd stage...", 0x0A, 0x0D, 0
   113 000006EB 2E2E2E0A0D00       
   114                                  
   115 000006F1 2044726976653A3078      .s1     db      " Drive:0x"
   116 000006FA 20202C20433A3078        .p1     db      "  , C:0x"
   117 00000702 202020202C20483A30-     .p2     db      "    , H:0x"
   117 0000070B 78                 
   118 0000070C 20202C20533A3078        .p3     db      "  , S:0x"
   119 00000714 20200A0D00              .p4     db      "  ", 0x0A, 0x0D, 0
   120                                  
   121 00000719 43616E277420676574-     .e0     db      "Can't get drive parameter. ", 0
   121 00000722 206472697665207061-
   121 0000072B 72616D657465722E20-
   121 00000734 00                 
   122                                  
   123                                  stage_3rd:
   124 00000735 68[B807]E893F983C4-             cdecl   puts, .s0
   124 0000073D 02                 
   125                                  
   126                                          ; フォントアドレスを取得(BIOSが利用するフォント)
   127 0000073E 68[0002]E88BFB83C4-             cdecl   get_font_adr, FONT
   127 00000746 02                 
   128                                  
   129                                          ; フォントアドレス表示
   130 00000747 6A046A106A0468-                 cdecl   itoa, word [FONT.seg], .p1, 4, 16, 0b0100
   130 0000074E [D407]FF36[0002]E8-
   130 00000755 B5FA83C40A         
   131 0000075A 6A046A106A0468-                 cdecl   itoa, word [FONT.off], .p2, 4, 16, 0b0100
   131 00000761 [D907]FF36[0202]E8-
   131 00000768 A2FA83C40A         
   132 0000076D 68[C707]E85BF983C4-             cdecl   puts, .s1
   132 00000775 02                 
   133                                  
   134                                          ; メモリ情報の取得と表示
   135 00000776 68[0402]E873FB83C4-             cdecl   get_mem_info, ACPI_DATA
   135 0000077E 02                 
   136                                  
   137 0000077F 66A1[0402]                      mov     eax, [ACPI_DATA.adr]
   138 00000783 6683F800                        cmp     eax, 0
   139 00000787 742D                            je      .10E
   140                                  
   141 00000789 6A046A106A0468-                 cdecl   itoa, ax, .p4, 4, 16, 0b0100
   141 00000790 [F307]50E876FA83C4-
   141 00000798 0A                 
   142 00000799 66C1E810                        shr     eax, 16
   143 0000079D 6A046A106A0468-                 cdecl   itoa, ax, .p3, 4, 16, 0b0100
   143 000007A4 [EE07]50E862FA83C4-
   143 000007AC 0A                 
   144 000007AD 68[E307]E81BF983C4-             cdecl   puts, .s2
   144 000007B5 02                 
   145                                  .10E:
   146 000007B6 EB42                            jmp     stage_4rd
   147                                  
   148                                  ; ローカルラベル
   149 000007B8 336E64207374616765-     .s0:    db "3nd stage...", 0x0A, 0x0D, 0
   149 000007C1 2E2E2E0A0D00       
   150 000007C7 20466F6E7420416472-     .s1:    db " Font Adress="
   150 000007D0 6573733D           
   151 000007D4 5A5A5A5A3A              .p1:    db "ZZZZ:"
   152 000007D9 5A5A5A5A0A0D00          .p2:    db "ZZZZ", 0x0A, 0x0D, 0
   153 000007E0 0A0D00                          db 0x0A, 0x0D, 0
   154                                  
   155 000007E3 204143504920646174-     .s2:    db " ACPI data="
   155 000007EC 613D               
   156 000007EE 5A5A5A5A3A              .p3:    db "ZZZZ:"
   157 000007F3 5A5A5A5A0A0D00          .p4:    db "ZZZZ", 0x0A, 0x0D, 0
   158                                  
   159                                  stage_4rd:
   160 000007FA 68[CE08]E8CEF883C4-             cdecl   puts, .s0
   160 00000802 02                 
   161                                          ; ----------------
   162                                          ; A20ゲートの有効化
   163                                          ; ----------------
   164                                          ; A20ゲート有効化途中の割り込み、キーボードの無効化
   165 00000803 FA                              cli
   166 00000804 68AD00E8CFFD83C402              cdecl KBC_cmd_write, 0xAD
   167                                  
   168                                          ; 出力ポート取得
   169 0000080D 68D000E8C6FD83C402              cdecl KBC_cmd_write, 0xD0  ; 読み込みコマンド実行
   170 00000816 68[1609]E89BFD83C4-             cdecl KBC_data_read, .key ; データ読み込み実行
   170 0000081E 02                 
   171                                  
   172                                          ; 出力ポートに対して、A20ゲートを有効化(BL |= 0x02)
   173 0000081F 8A1E[1609]                      mov bl, [.key]
   174 00000823 80CB02                          or bl, 0x02
   175                                  
   176                                          ; 変更後の出力ポートを書き込み
   177 00000826 68D100E8ADFD83C402              cdecl KBC_cmd_write, 0xD1 ; 書き込みコマンド実行
   178 0000082F 53E884FD83C402                  cdecl KBC_data_read, bx  ; データ書き込み実行
   179                                  
   180                                          ; 割り込み、キーボード無効化を解除
   181 00000836 68AE00E89DFD83C402              cdecl KBC_cmd_write, 0xAE
   182 0000083F FB                              sti
   183                                  
   184                                          ; 終了メッセージ表示
   185 00000840 68[DD08]E888F883C4-             cdecl puts, .s1
   185 00000848 02                 
   186                                  
   187                                          ; --------------------
   188                                          ; キーボードLEDのテスト
   189                                          ; --------------------
   190 00000849 68[F208]E87FF883C4-             cdecl puts, .s2
   190 00000851 02                 
   191                                  
   192 00000852 BB0000                          mov bx, 0 ; bx: LEDの初期値
   193                                  
   194                                  .10L:
   195 00000855 B400                            mov ah, 0x00
   196 00000857 CD16                            int 0x16
   197                                  
   198 00000859 3C31                            cmp al, '1'
   199 0000085B 7266                            jb .10E
   200                                  
   201 0000085D 3C33                            cmp al, '3'
   202 0000085F 7762                            ja .10E
   203                                  
   204 00000861 88C1                            mov cl, al
   205 00000863 FEC9                            dec cl
   206 00000865 80E103                          and cl, 0x03
   207 00000868 B80100                          mov ax, 0x0001
   208 0000086B D3E0                            shl ax, cl
   209 0000086D 31C3                            xor bx, ax
   210                                  
   211                                          ; --------------------
   212                                          ; LEDコマンドの送信
   213                                          ; --------------------
   214                                  
   215                                          ; 割り込み、キーボードを無効化
   216 0000086F FA                              cli
   217 00000870 68AD00E863FD83C402              cdecl KBC_cmd_write, 0xAD
   218                                  
   219                                          ; LEDコマンド実行、応答受信
   220 00000879 68ED00E81AFD83C402              cdecl KBC_data_write, 0xED
   221 00000882 68[1609]E82FFD83C4-             cdecl KBC_data_read, .key
   221 0000088A 02                 
   222                                  
   223                                          ; キーボードが正常に応答できた場合(0xFA: ACK(Acknowledge))
   224 0000088B 803E[1609]FA                    cmp [.key], byte 0xFA
   225 00000890 7509                            jne .11F
   226                                  
   227 00000892 53E803FD83C402                  cdecl KBC_data_write, bx
   228 00000899 EB1C                            jmp .11E
   229                                  .11F:
   230 0000089B 6A046A106A0268-                 cdecl itoa, word [.key], .e1, 2, 16, 0b0100
   230 000008A2 [1209]FF36[1609]E8-
   230 000008A9 61F983C40A         
   231 000008AE 68[1109]E81AF883C4-             cdecl puts, .e0
   231 000008B6 02                 
   232                                  .11E:
   233                                          ; 割り込み、キーボード有効化
   234 000008B7 68AE00E81CFD83C402              cdecl KBC_cmd_write, 0xAE
   235 000008C0 FB                              sti
   236                                  
   237 000008C1 EB92                            jmp .10L
   238                                  .10E:
   239                                          ; 文字列表示
   240 000008C3 68[0809]E805F883C4-             cdecl puts, .s3
   240 000008CB 02                 
   241                                  
   242 000008CC EB4A                            jmp stage_5rd
   243                                  
   244 000008CE 346E64207374616765-     .s0:    db "4nd stage...", 0x0A, 0x0D, 0
   244 000008D7 2E2E2E0A0D00       
   245 000008DD 204132302047617465-     .s1:    db " A20 Gate Enabled.", 0x0A, 0x0D, 0
   245 000008E6 20456E61626C65642E-
   245 000008EF 0A0D00             
   246 000008F2 206B6579626F617264-     .s2:    db " keyboard LED test...", 0
   246 000008FB 204C45442074657374-
   246 00000904 2E2E2E00           
   247 00000908 28446F6E65290A0D00      .s3:    db "(Done)", 0x0A, 0x0D, 0
   248 00000911 5B                      .e0:    db "["
   249 00000912 5A5A5D00                .e1:    db "ZZ]", 0
   250                                  
   251                                  ; KBC出力ポートの保存バッファ
   252 00000916 0000                    .key:   dw 0
   253                                  
   254                                  stage_5rd:
   255                                          ; 5rd 処理開始
   256 00000918 68[4409]E8B0F783C4-             cdecl   puts, .s0
   256 00000920 02                 
   257                                  
   258                                          ; カーネル読み込み
   259                                          ; AX(読み込んだセクタ数) = read_lba(drive, lba, sect, dst)
   260 00000921 68009C6A106A1068-               cdecl read_lba, BOOT, BOOT_SECT, KERNEL_SECT, BOOT_END
   260 00000929 [C600]E804FD83C408 
   261 00000931 83F810                          cmp ax, KERNEL_SECT
   262                                  .10Q:
   263 00000934 740C                            jz .10E
   264                                  .10T:   
   265 00000936 68[5309]E892F783C4-             cdecl puts, .e0
   265 0000093E 02                 
   266 0000093F E8ABF7                          call reboot
   267                                  .10E:
   268 00000942 EB29                            jmp stage_6rd
   269                                  
   270 00000944 356E64207374616765-     .s0:    db "5nd stage...", 0x0A, 0x0D, 0
   270 0000094D 2E2E2E0A0D00       
   271 00000953 2046616C6975726520-     .e0:    db " Faliure load kernel...", 0x0A, 0x0D, 0
   271 0000095C 6C6F6164206B65726E-
   271 00000965 656C2E2E2E0A0D00   
   272                                  
   273                                  
   274                                  stage_6rd:
   275                                          ; 6rd 処理開始
   276 0000096D 68[8509]E85BF783C4-             cdecl   puts, .s0
   276 00000975 02                 
   277                                  
   278                                          ; ユーザーからの入力待ち
   279                                  .10L:
   280 00000976 B400                            mov ah, 0x00
   281 00000978 CD16                            int 0x16
   282 0000097A 3C20                            cmp al, ' '
   283 0000097C 75F8                            jne .10L
   284                                          
   285                                          ; ビデオモードの設定
   286 0000097E B81200                          mov ax, 0x0012  ; VGA 640×480
   287 00000981 CD10                            int 0x10
   288                                  
   289                                          ; 処理終了
   290 00000983 EB5B                            jmp     stage_7rd
   291                                  
   292 00000985 366E64207374616765-     .s0:    db "6nd stage...", 0x0A, 0x0D, 0x0A, 0x0D
   292 0000098E 2E2E2E0A0D0A0D     
   293 00000995 5B5075736820535041-             db "[Push SPACE Key to protect mode...]", 0x0A, 0x0D, 0
   293 0000099E 4345204B657920746F-
   293 000009A7 2070726F7465637420-
   293 000009B0 6D6F64652E2E2E5D0A-
   293 000009B9 0D00               
   294                                  
   295                                  
   296                                  ; --------------------------------
   297                                  ; セグメントディスクリプターの配列
   298                                  ; --------------------------------
   299 000009BB 00                      ALIGN 4, db 0
   300 000009BC 0000000000000000        GDT:    dq 0x00_0_0_0_0_000000_0000     ; NULL
   301 000009C4 FFFF0000009ACF00        .cs:    dq 0x00_C_F_9_A_000000_FFFF     ; CODE 4G(実行/Read可)
   302 000009CC FFFF00000092CF00        .ds:    dq 0x00_C_F_9_2_000000_FFFF     ; DATA 4G(Read/Write可)
   303                                  .gdt_end:
   304                                  
   305                                  ; --------------------------------
   306                                  ; セレクタ
   307                                  ; --------------------------------
   308                                  SEL_CODE equ GDT.cs - GDT               ; コード用セレクタ
   309                                  SEL_DATA equ GDT.ds - GDT               ; データ用セレクタ
   310                                  
   311                                  ; --------------------------------
   312                                  ; GDTR(Global Discripter Table Registor)
   313                                  ; --------------------------------
   314 000009D4 1700                    GDTR: dw GDT.gdt_end - GDT - 1          ; ディスクリプタテーブルのリミット
   315 000009D6 [BC090000]                    dd GDT                            ; ディスクリプタテーブルのアドレス
   316                                  
   317                                  ; --------------------------------
   318                                  ; IDT(擬似: 割り込み禁止にするためだけ)
   319                                  ; --------------------------------
   320 000009DA 0000                    IDTR: dw 0                              ; IDTリミット
   321 000009DC 00000000                      dd 0                              ; IDTアドレス
   322                                  
   323                                  stage_7rd:
   324                                          ; 割り込み禁止
   325 000009E0 FA                              cli
   326                                  
   327                                          ; ディスクリプタテーブルの読み込み
   328 000009E1 0F0116[D409]                    lgdt [GDTR]     ; GDTRをロード
   329 000009E6 0F011E[DA09]                    lidt [IDTR]     ; 割り込み用のディスクリプタテーブルを読み込み
   330                                  
   331                                          ; プロテクトモードへ移行
   332 000009EB 0F20C0                          mov eax, cr0    
   333 000009EE 83C801                          or  ax, 1
   334 000009F1 0F22C0                          mov cr0, eax
   335                                  
   336                                          ; リアルモードで読み込んだコードをCPU内部からクリアする
   337 000009F4 EB00                            jmp $ + 2
   338                                  
   339                                          ; セグメント間ジャンプ
   340                                  [BITS 32]
   341                                          ; オペランドサイズオーバーライドプレフィックスを設定し、32ビット値を正しく読み込めるようにする
   342 000009F6 66                              DB 0x66
   343 000009F7 EA[FE090000]0800                jmp SEL_CODE:CODE_32
   344                                  
   345                                  
   346                                  ; --------------------------------
   347                                  ; 32ビットコード開始
   348                                  ; --------------------------------
   349                                  CODE_32:
   350                                          ; セレクタ初期化。各セグメントレジスタに対して、データ用のセグメントディスクリプタ(へのオフセット)を設定。
   351 000009FE 66B81000                        mov ax, SEL_DATA
   352 00000A02 8ED8                            mov ds, ax
   353 00000A04 8EC0                            mov es, ax
   354 00000A06 8EE0                            mov fs, ax
   355 00000A08 8EE8                            mov gs, ax
   356 00000A0A 8ED0                            mov ss, ax
   357                                  
   358                                          ; カーネル部をコピー
   359 00000A0C B900080000                      mov ecx, (KERNEL_SIZE) / 4      ; ECX = 4バイト単位でコピー
   360 00000A11 BE009C0000                      mov esi, BOOT_END               ; ESI = カーネル部の先頭アドレス
   361 00000A16 BF00101000                      mov edi, KERNEL_LOAD            ; EDI = カーネルのロード先
   362 00000A1B FC                              cld                             ; DFクリア(+方向にコピー)
   363 00000A1C F3A5                            rep movsd                       ; while(ECX++) { *EDI++ = *ESI++; }
   364                                  
   365                                          ; カーネル処理に移行
   366 00000A1E E9(00101000)                    jmp     KERNEL_LOAD
   367                                  
   368                                  ; -------------
   369                                  ; パディング
   370                                  ; -------------
   371 00000A23 00<rept>                        times BOOT_SIZE - ($ - $$) db 0        ; 8Kバイト

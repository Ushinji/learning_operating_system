     1                                  ; **********************************************
     2                                  ; read_chs
     3                                  ; **********************************************
     4                                  %include "../include/macro.s"
     1                              <1> ; %macro <マクロ名> <引数の数>
     2                              <1> ; 1-*: 1つ以上の引数が指定されることを示す
     3                              <1> ; .nolist: マクロのリスト出力を抑止
     4                              <1> %macro  cdecl 1-*.nolist
     5                              <1> 
     6                              <1>     ; -------------------------------------------------
     7                              <1>     ; 引数リストから、呼び出し関数の引数を末尾から順にpushする
     8                              <1>     ; -------------------------------------------------
     9                              <1>     ; %rep <number>: %rep -> %endrepの間を指定回数分ループする
    10                              <1>     ; %0 - 1: 呼び出し関数への引数の数(%0は引数の数を表す。引数の数から、呼び出し関数そのものを数から引くと呼び出し関数への引数の数となる)
    11                              <1>     %rep    %0 - 1
    12                              <1>         ; 引数リストの末尾の値をpushする
    13                              <1>         ; %{-1:-1}: 引数リストの末尾を表す
    14                              <1>         push    %{-1:-1}
    15                              <1> 
    16                              <1>         ; %rotate: 引数リストを指定した数だけずらす
    17                              <1>         ; 今回は末尾から引数をpushしたいので、負の数を指定し右方向へ動かす
    18                              <1>         ; ※動作例
    19                              <1>         ; [1, 2, 3, 4] -> (%rotate -1) -> [4, 1, 2, 3]
    20                              <1>         %rotate -1
    21                              <1>     %endrep
    22                              <1> 
    23                              <1>     ; 引数リストの順番を元に戻す
    24                              <1>     %rotate - 1
    25                              <1> 
    26                              <1>     ; 関数呼び出し
    27                              <1>     call    %1
    28                              <1>     
    29                              <1>     ; 引数が与えられている場合
    30                              <1>     %if 1 < %0
    31                              <1>         ; 呼び出し関数への引数分だけスタックの破棄(スタックポインタ(SP)の調整)
    32                              <1>         ; __BITS__: ビットモード判定(実行環境に応じた値(16 or 32 or 64)が得られる)
    33                              <1>         ; ビットモードを3ビット分右にシフト(1/8)すると、バイトサイズが得られる
    34                              <1>         ; * 16ビットモード: 2バイト
    35                              <1>         ; * 32ビットモード: 4バイト
    36                              <1>         ; * 64ビットモード: 8バイト
    37                              <1>         add sp, (__BITS__ >> 3) * (%0 - 1)
    38                              <1>     %endif
    39                              <1> 
    40                              <1> %endmacro
    41                              <1> 
    42                              <1> struc drive
    43 00000000 <res 00000002>      <1>     .no resw 1      ; ドライブ番号
    44 00000002 <res 00000002>      <1>     .cyln resw 1    ; シリンダ
    45 00000004 <res 00000002>      <1>     .head resw 1    ; ヘッド
    46 00000006 <res 00000002>      <1>     .sect resw 1    ; セクタ
    47                              <1> endstruc
     5                                  %include "../include/define.s"
     1                              <1>     BOOT_LOAD   equ     0x7C00                  ; ブートプログラムのロード位置
     2                              <1>     BOOT_SIZE   equ     (1024 * 8)              ; ブートコードのサイズ
     3                              <1>     SECT_SIZE   equ     (512)                   ; セクタサイズ
     4                              <1>     BOOT_SECT   equ     (BOOT_SIZE / SECT_SIZE) ; ブートプログラムのセクタ数
     6                                  
     7                                          ORG     BOOT_LOAD
     8                                  
     9                                  entry:
    10 00000000 EB58                            jmp     ipl
    11 00000002 90<rept>                        times 90 - ($ - $$) db 0x90
    12                                  ipl:
    13 0000005A FA                              cli                                     ; BIOSからの割り込みを禁止
    14 0000005B B80000                          mov     ax, 0x0000                      ; Accumulate(蓄積) Register = 0x0000
    15 0000005E 8ED8                            mov     ds, ax                          ; Data Segment  = 0x0000
    16 00000060 8EC0                            mov     es, ax                          ; Extra Segment = 0x0000
    17 00000062 8ED0                            mov     ss, ax                          ; Stack Segment = 0x0000
    18 00000064 BC007C                          mov     sp, BOOT_LOAD                   ; Stack Point   = 0x7C00
    19                                  
    20 00000067 FB                              sti                                     ; BIOSからの割り込みを許可
    21                                  
    22 00000068 8816[C600]                      mov     [BOOT + drive.no], dl           ; ブートドライブを保存
    23                                  
    24 0000006C 68[9900]E85C0083C4-             cdecl   puts, .s0
    24 00000074 02                 
    25                                  
    26                                          ; 残りのセクタをすべて読み込む
    27 00000075 BB0F00                          mov     bx, BOOT_SECT - 1               ; BX=残りのブートセクタ数
    28 00000078 B9007E                          mov     cx, BOOT_LOAD + SECT_SIZE       ; CX=次のロードアドレス
    29                                  
    30 0000007B 515368[C600]E8A900-             cdecl   read_chs, BOOT, bx, cx          ; セクタ読み込み実行
    30 00000083 83C406             
    31                                  
    32 00000086 39D8                            cmp     ax, bx                          ; 戻り値(AX) != 残りのセクタ数(bx) -> 再起動する
    33 00000088 740C                    .10Q:   jz      .10E
    34 0000008A 68[B200]E83E0083C4-     .10T:   cdecl   puts, .e0
    34 00000092 02                 
    35 00000093 E85700                          call    reboot
    36                                  .10E:
    37                                  
    38                                          ; 次ステージへ移行
    39 00000096 E96701                          jmp     stage_2
    40                                  
    41                                  ; データ定義
    42                                  ; 0x0A(LF.カーソル位置を一行下げる), 0x0D(CR.カーソル位置を左端に移動する)
    43 00000099 426F6F74696E672E2E-     .s0     db      "Booting....", 0x0A, 0x0D, 0
    43 000000A2 2E2E0A0D00         
    44 000000A7 2D2D2D2D2D2D2D2D0A-     .s1     db      "--------", 0x0A, 0x0D, 0
    44 000000B0 0D00               
    45 000000B2 4572726F723A736563-     .e0     db      "Error:sector read", 0x0A, 0x0D, 0
    45 000000BB 746F7220726561640A-
    45 000000C4 0D00               
    46                                  
    47                                  
    48                                  
    49                                  ; ブートドライブに関する情報
    50                                  ALIGN 2, db 0                                   ; ALIGNディレクティブ。データを2バイト境界で配置するように指示
    51                                  BOOT:
    52                                          istruc drive
    53 000000C6 0000                                 at drive.no,       dw  0           ; ドライブ番号
    54 000000C8 0000                                 at drive.cyln,     dw  0           ; C: シリンダ
    55 000000CA 0000                                 at drive.head,     dw  0           ; H: ヘッド
    56 000000CC 0200                                 at drive.sect,     dw  2           ; S: セクタ
    57                                          iend
    58                                          
    59                                  ; モジュール読み込み
    60                                  %include        "../modules/real/puts.s"
     1                              <1> ; ******************************
     2                              <1> ; void puts(str);
     3                              <1> ; -----------------
     4                              <1> ; str: 文字列のアドレス
     5                              <1> ; -----------------
     6                              <1> ; ******************************
     7                              <1> 
     8                              <1> ; // ****************
     9                              <1> ; // レジスタ位置関係
    10                              <1> ; // ****************
    11                              <1> ;   + 4 | str
    12                              <1> ;   + 2 | 戻り番地
    13                              <1> ; BP+ 0 | BP
    14                              <1> 
    15                              <1> puts:
    16                              <1>     ; スタックフレームの構築
    17 000000CE 55                  <1>     push    bp
    18 000000CF 89E5                <1>     mov     bp, sp
    19                              <1> 
    20                              <1>     ; レジスタの保存
    21 000000D1 50                  <1>     push    ax              ;AX: Accumulate Register
    22 000000D2 53                  <1>     push    bx              ;BX: Base Register
    23 000000D3 56                  <1>     push    si              ;SI: Source Register。ストリーム操作コマンド（たとえば MOV命令）でのソース（入力元）へのポインタとして使用
    24                              <1> 
    25                              <1>     ; 引数取得
    26 000000D4 8B7604              <1>     mov     si, [bp + 4]
    27                              <1> 
    28                              <1>     ; 処理開始
    29 000000D7 B40E                <1>     mov     ah, 0x0E        ; AH(AXの上位(Hight)8bit)に、テレタイプ式1文字出力を設定
    30 000000D9 BB0000              <1>     mov     bx, 0x0000      ; ページ番号と文字色を0に設定
    31 000000DC FC                  <1>     cld                     ; Clear Direction Flag. DF=0で+方向に設定
    32                              <1> .10L:
    33                              <1>     ; LODSB命令: SIレジスタに指定されたアドレスから1バイト分のデータをALレジスタに読み込む。
    34                              <1>     ; そして、SIレジスタの値を1加算(or減算)を行う。今回はDF=0のため加算される)
    35 000000DD AC                  <1>     lodsb
    36                              <1>     
    37                              <1>     ; ALレジスタを比較し0x00(終端文字)の場合は処理終了
    38                              <1>     ; 終端文字ではない場合は、該当文字の文字を出力し、処理を繰り返す
    39 000000DE 3C00                <1>     cmp     al, 0
    40 000000E0 7404                <1>     je      .10E
    41 000000E2 CD10                <1>     int     0x10            ; ビデオBIOSコール(INT10)
    42 000000E4 EBF7                <1>     jmp     .10L
    43                              <1> .10E:
    44                              <1> 
    45                              <1>     ; レジスタの復帰
    46 000000E6 5E                  <1>     pop si
    47 000000E7 5B                  <1>     pop bx
    48 000000E8 58                  <1>     pop ax
    49                              <1> 
    50                              <1>     ; スタックフレームの破棄
    51 000000E9 89EC                <1>     mov sp, bp
    52 000000EB 5D                  <1>     pop bp
    53                              <1> 
    54                              <1>     ; 呼び出し元へ戻る
    55 000000EC C3                  <1>     ret
    61                                  %include        "../modules/real/reboot.s"
     1                              <1> reboot:
     2                              <1>     ; 再起動の説明を出力
     3 000000ED 68[0901]E8DBFF83C4- <1>     cdecl   puts, .s0
     3 000000F5 02                  <1>
     4                              <1> 
     5                              <1> .10L:
     6                              <1>     ; キー入力待ち
     7 000000F6 B410                <1>     mov     ah, 0x10
     8 000000F8 CD16                <1>     int     0x16
     9                              <1> 
    10                              <1>     ; キー入力が空白文字ではない場合、再度キー入力待ちへ戻る
    11 000000FA 3C20                <1>     cmp     al, ' '
    12 000000FC 75F8                <1>     jne     .10L
    13                              <1> 
    14                              <1>     ; 改行出力
    15 000000FE 68[2701]E8CAFF83C4- <1>     cdecl   puts, .s1
    15 00000106 02                  <1>
    16                              <1> 
    17                              <1>     ; 再起動
    18 00000107 CD19                <1>     int     0x19
    19                              <1> 
    20                              <1> 
    21                              <1>     ; 文字列データ
    22 00000109 0A0D50757368205350- <1> .s0     db 0x0A, 0x0D, "Push SPACE Key to reboot...", 0
    22 00000112 414345204B65792074- <1>
    22 0000011B 6F207265626F6F742E- <1>
    22 00000124 2E2E00              <1>
    23 00000127 0A0D0A0D00          <1> .s1     db 0x0A, 0x0D, 0x0A, 0x0D, 0
    24                              <1> 
    62                                  %include        "../modules/real/read_chs.s"
     1                              <1> ; int read_chs(drive, sect, dst);
     2                              <1> ; @params drive :drive構造体のアドレス
     3                              <1> ; @params sect  :読み出しセクタ数
     4                              <1> ; @params dst   :読み出し先アドレス 
     5                              <1> ; @return       :読み込んだセクタ数
     6                              <1> 
     7                              <1> 
     8                              <1> ; // ****************
     9                              <1> ; // レジスタ位置関係
    10                              <1> ; // ****************
    11                              <1> ;   + 8 | dst
    12                              <1> ;   + 6 | sect
    13                              <1> ;   + 4 | drive
    14                              <1> ;   + 2 | 戻り番地
    15                              <1> ; BP+ 0 | BP
    16                              <1> ; -----------------
    17                              <1> ;   - 2 | retry = 3(読み込みリトライ回数)
    18                              <1> ;   - 4 | sect  = 0(読み込みセクタ数)
    19                              <1> 
    20                              <1> read_chs:
    21                              <1>     ; スタックフレームの構築
    22 0000012C 55                  <1>     push    bp
    23 0000012D 89E5                <1>     mov     bp, sp
    24 0000012F 6A03                <1>     push    3
    25 00000131 6A00                <1>     push    0       
    26                              <1> 
    27                              <1>     ; レジスタの保存
    28 00000133 53                  <1>     push    bx
    29 00000134 51                  <1>     push    cx
    30 00000135 52                  <1>     push    dx
    31 00000136 06                  <1>     push    es
    32 00000137 56                  <1>     push    si
    33                              <1> 
    34                              <1>     ; 処理の開始
    35 00000138 8B7604              <1>     mov     si, [bp + 4]                ; drive構造体のアドレスを取得
    36                              <1>     
    37                              <1>     ; CXレジスタの設定
    38 0000013B 8A6C02              <1>     mov     ch, [si + drive.cyln + 0]   ; CH = シリンダ番号(下位バイト)
    39 0000013E 8A4C03              <1>     mov     cl, [si + drive.cyln + 1]   ; CL = シリンダ番号(上位バイト)
    40 00000141 C0E106              <1>     shl     cl, 6                       ; CL <<= 6; 上位2ビットにシフト 0x11 -> 0x110000
    41 00000144 0A4C06              <1>     or      cl, [si + drive.sect]       ; CL |= セクタ番号(0x110000 | 0x1 = 0x110001)
    42                              <1> 
    43                              <1>     ; セクタ読み込み
    44 00000147 8A7404              <1>     mov     dh, [si + drive.head]       ; DH = ヘッド取得
    45 0000014A 8A14                <1>     mov     dl, [si + 0]                ; DL = ドライブ番号
    46 0000014C B80000              <1>     mov     ax, 0x0000                  ; AX = 0x0000
    47 0000014F 8EC0                <1>     mov     es, ax                      ; ES = セグメント
    48 00000151 8B5E08              <1>     mov     bx, [bp + 8]                ; BX = コピー先(dst)
    49                              <1> .10L:
    50 00000154 B402                <1>     mov     ah, 0x02                    ; AH = セクタ読み込み命令
    51 00000156 8A4606              <1>     mov     al, [bp + 6]                ; AL = 読み込みセクタ数(sect)
    52                              <1> 
    53 00000159 CD13                <1>     int     0x13                        ; セクタ読み込み実行: BIOS(0x13, 0x02): セクタ読み出し
    54 0000015B 7304                <1>     jnc     .11E                        ; 
    55 0000015D B000                <1>     mov     al, 0
    56 0000015F EB0C                <1>     jmp     .10E
    57                              <1> .11E:
    58 00000161 3C00                <1>     cmp     al, 0                       ; 読み込みセクタ数を0
    59 00000163 7508                <1>     jne     .10E
    60                              <1> 
    61 00000165 B80000              <1>     mov     ax, 0
    62 00000168 FF4EFE              <1>     dec     word [bp - 2]               ; リトライ回数をデクリメント
    63 0000016B 75E7                <1>     jnz     .10L                        ; 一行前のデクリメント結果が0でない場合、ループする
    64                              <1> .10E:
    65 0000016D B400                <1>     mov     ah, 0                       ; ステータス情報を破棄
    66                              <1> 
    67                              <1>     ; レジスタの復帰
    68 0000016F 5E                  <1>     pop     si
    69 00000170 07                  <1>     pop     es
    70 00000171 5A                  <1>     pop     dx
    71 00000172 59                  <1>     pop     cx
    72 00000173 5B                  <1>     pop     bx
    73                              <1> 
    74                              <1>     ; スタックフレームの破棄
    75 00000174 89EC                <1>     mov     sp, bp
    76 00000176 5D                  <1>     pop     bp
    77                              <1> 
    78 00000177 C3                  <1>     ret
    63                                  
    64                                          ; プートフラグの定義
    65 00000178 00<rept>                        times 510 - ($ - $$) db 0x00
    66 000001FE 55AA                            db 0x55, 0xAA
    67                                  
    68                                  stage_2:
    69 00000200 68[0B02]E8C8FE83C4-             cdecl   puts, .s0
    69 00000208 02                 
    70 00000209 EBFE                            jmp     $
    71                                  
    72                                  ; データ定義
    73 0000020B 326E64207374616765-     .s0     db      "2nd stage...", 0x0A, 0x0D, 0
    73 00000214 2E2E2E0A0D00       
    74                                  
    75                                          ; ブートプログラムを8Kバイトとして定義
    76 0000021A 00<rept>                        times BOOT_SIZE - ($ - $$) db 0        ; 8Kバイト

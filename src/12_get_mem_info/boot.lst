     1                                  ; **********************************************
     2                                  ; font_address
     3                                  ; **********************************************
     4                                  %include "../include/macro.s"
     1                              <1> ; %macro <マクロ名> <引数の数>
     2                              <1> ; 1-*: 1つ以上の引数が指定されることを示す
     3                              <1> ; .nolist: マクロのリスト出力を抑止
     4                              <1> %macro  cdecl 1-*.nolist
     5                              <1> 
     6                              <1>     ; -------------------------------------------------
     7                              <1>     ; 引数リストから、呼び出し関数の引数を末尾から順にpushする
     8                              <1>     ; -------------------------------------------------
     9                              <1>     ; %rep <number>: %rep -> %endrepの間を指定回数分ループする
    10                              <1>     ; %0 - 1: 呼び出し関数への引数の数(%0は引数の数を表す。引数の数から、呼び出し関数そのものを数から引くと呼び出し関数への引数の数となる)
    11                              <1>     %rep    %0 - 1
    12                              <1>         ; 引数リストの末尾の値をpushする
    13                              <1>         ; %{-1:-1}: 引数リストの末尾を表す
    14                              <1>         push    %{-1:-1}
    15                              <1> 
    16                              <1>         ; %rotate: 引数リストを指定した数だけずらす
    17                              <1>         ; 今回は末尾から引数をpushしたいので、負の数を指定し右方向へ動かす
    18                              <1>         ; ※動作例
    19                              <1>         ; [1, 2, 3, 4] -> (%rotate -1) -> [4, 1, 2, 3]
    20                              <1>         %rotate -1
    21                              <1>     %endrep
    22                              <1> 
    23                              <1>     ; 引数リストの順番を元に戻す
    24                              <1>     %rotate - 1
    25                              <1> 
    26                              <1>     ; 関数呼び出し
    27                              <1>     call    %1
    28                              <1>     
    29                              <1>     ; 引数が与えられている場合
    30                              <1>     %if 1 < %0
    31                              <1>         ; 呼び出し関数への引数分だけスタックの破棄(スタックポインタ(SP)の調整)
    32                              <1>         ; __BITS__: ビットモード判定(実行環境に応じた値(16 or 32 or 64)が得られる)
    33                              <1>         ; ビットモードを3ビット分右にシフト(1/8)すると、バイトサイズが得られる
    34                              <1>         ; * 16ビットモード: 2バイト
    35                              <1>         ; * 32ビットモード: 4バイト
    36                              <1>         ; * 64ビットモード: 8バイト
    37                              <1>         add sp, (__BITS__ >> 3) * (%0 - 1)
    38                              <1>     %endif
    39                              <1> 
    40                              <1> %endmacro
    41                              <1> 
    42                              <1> struc drive
    43 00000000 <res 00000002>      <1>     .no resw 1      ; ドライブ番号
    44 00000002 <res 00000002>      <1>     .cyln resw 1    ; シリンダ
    45 00000004 <res 00000002>      <1>     .head resw 1    ; ヘッド
    46 00000006 <res 00000002>      <1>     .sect resw 1    ; セクタ
    47                              <1> endstruc
     5                                  %include "../include/define.s"
     1                              <1>     BOOT_LOAD        equ    0x7C00                  ; ブートプログラムのロード位置
     2                              <1>     BOOT_SIZE        equ    (1024 * 8)              ; ブートコードのサイズ
     3                              <1>     SECT_SIZE        equ    (512)                   ; セクタサイズ
     4                              <1>     BOOT_SECT        equ    (BOOT_SIZE / SECT_SIZE) ; ブートプログラムのセクタ数
     5                              <1>     
     6                              <1>     E820_RECORD_SIZE equ    20                      ; 取得したメモリ情報を格納する領域サイズ
     6                                  
     7                                          ORG     BOOT_LOAD
     8                                  
     9                                  entry:
    10 00000000 EB58                            jmp     ipl
    11 00000002 90<rept>                        times 90 - ($ - $$) db 0x90
    12                                  ipl:
    13 0000005A FA                              cli                                     ; BIOSからの割り込みを禁止
    14 0000005B B80000                          mov     ax, 0x0000                      ; Accumulate(蓄積) Register = 0x0000
    15 0000005E 8ED8                            mov     ds, ax                          ; Data Segment  = 0x0000
    16 00000060 8EC0                            mov     es, ax                          ; Extra Segment = 0x0000
    17 00000062 8ED0                            mov     ss, ax                          ; Stack Segment = 0x0000
    18 00000064 BC007C                          mov     sp, BOOT_LOAD                   ; Stack Point   = 0x7C00
    19                                  
    20 00000067 FB                              sti                                     ; BIOSからの割り込みを許可
    21                                  
    22 00000068 8816[C600]                      mov     [BOOT + drive.no], dl           ; ブートドライブを保存
    23                                  
    24 0000006C 68[9900]E85C0083C4-             cdecl   puts, .s0
    24 00000074 02                 
    25                                  
    26                                          ; 残りのセクタをすべて読み込む
    27 00000075 BB0F00                          mov     bx, BOOT_SECT - 1               ; BX=残りのブートセクタ数
    28 00000078 B9007E                          mov     cx, BOOT_LOAD + SECT_SIZE       ; CX=次のロードアドレス
    29                                  
    30 0000007B 515368[C600]E8A900-             cdecl   read_chs, BOOT, bx, cx          ; セクタ読み込み実行
    30 00000083 83C406             
    31                                  
    32 00000086 39D8                            cmp     ax, bx                          ; 戻り値(AX) != 残りのセクタ数(bx) -> 再起動する
    33 00000088 740C                    .10Q:   jz      .10E
    34 0000008A 68[B200]E83E0083C4-     .10T:   cdecl   puts, .e0
    34 00000092 02                 
    35 00000093 E85700                          call    reboot
    36                                  .10E:
    37                                  
    38                                          ; 次ステージへ移行
    39 00000096 E90005                          jmp     stage_2
    40                                  
    41                                  ; データ定義
    42                                  ; 0x0A(LF.カーソル位置を一行下げる), 0x0D(CR.カーソル位置を左端に移動する)
    43 00000099 426F6F74696E672E2E-     .s0     db      "Booting....", 0x0A, 0x0D, 0
    43 000000A2 2E2E0A0D00         
    44 000000A7 2D2D2D2D2D2D2D2D0A-     .s1     db      "--------", 0x0A, 0x0D, 0
    44 000000B0 0D00               
    45 000000B2 4572726F723A736563-     .e0     db      "Error:sector read", 0x0A, 0x0D, 0
    45 000000BB 746F7220726561640A-
    45 000000C4 0D00               
    46                                  
    47                                  ; ブートドライブに関する情報
    48                                  ALIGN 2, db 0                                   ; ALIGNディレクティブ。データを2バイト境界で配置するように指示
    49                                  BOOT:
    50                                          istruc drive
    51 000000C6 0000                                 at drive.no,       dw  0           ; ドライブ番号
    52 000000C8 0000                                 at drive.cyln,     dw  0           ; C: シリンダ
    53 000000CA 0000                                 at drive.head,     dw  0           ; H: ヘッド
    54 000000CC 0200                                 at drive.sect,     dw  2           ; S: セクタ
    55                                          iend
    56                                          
    57                                  ; モジュール読み込み
    58                                  %include        "../modules/real/puts.s"
     1                              <1> ; ******************************
     2                              <1> ; void puts(str);
     3                              <1> ; -----------------
     4                              <1> ; str: 文字列のアドレス
     5                              <1> ; -----------------
     6                              <1> ; ******************************
     7                              <1> 
     8                              <1> ; // ****************
     9                              <1> ; // レジスタ位置関係
    10                              <1> ; // ****************
    11                              <1> ;   + 4 | str
    12                              <1> ;   + 2 | 戻り番地
    13                              <1> ; BP+ 0 | BP
    14                              <1> 
    15                              <1> puts:
    16                              <1>     ; スタックフレームの構築
    17 000000CE 55                  <1>     push    bp
    18 000000CF 89E5                <1>     mov     bp, sp
    19                              <1> 
    20                              <1>     ; レジスタの保存
    21 000000D1 50                  <1>     push    ax              ;AX: Accumulate Register
    22 000000D2 53                  <1>     push    bx              ;BX: Base Register
    23 000000D3 56                  <1>     push    si              ;SI: Source Register。ストリーム操作コマンド（たとえば MOV命令）でのソース（入力元）へのポインタとして使用
    24                              <1> 
    25                              <1>     ; 引数取得
    26 000000D4 8B7604              <1>     mov     si, [bp + 4]
    27                              <1> 
    28                              <1>     ; 処理開始
    29 000000D7 B40E                <1>     mov     ah, 0x0E        ; AH(AXの上位(Hight)8bit)に、テレタイプ式1文字出力を設定
    30 000000D9 BB0000              <1>     mov     bx, 0x0000      ; ページ番号と文字色を0に設定
    31 000000DC FC                  <1>     cld                     ; Clear Direction Flag. DF=0で+方向に設定
    32                              <1> .10L:
    33                              <1>     ; LODSB命令: SIレジスタに指定されたアドレスから1バイト分のデータをALレジスタに読み込む。
    34                              <1>     ; そして、SIレジスタの値を1加算(or減算)を行う。今回はDF=0のため加算される)
    35 000000DD AC                  <1>     lodsb
    36                              <1>     
    37                              <1>     ; ALレジスタを比較し0x00(終端文字)の場合は処理終了
    38                              <1>     ; 終端文字ではない場合は、該当文字の文字を出力し、処理を繰り返す
    39 000000DE 3C00                <1>     cmp     al, 0
    40 000000E0 7404                <1>     je      .10E
    41 000000E2 CD10                <1>     int     0x10            ; ビデオBIOSコール(INT10)
    42 000000E4 EBF7                <1>     jmp     .10L
    43                              <1> .10E:
    44                              <1> 
    45                              <1>     ; レジスタの復帰
    46 000000E6 5E                  <1>     pop si
    47 000000E7 5B                  <1>     pop bx
    48 000000E8 58                  <1>     pop ax
    49                              <1> 
    50                              <1>     ; スタックフレームの破棄
    51 000000E9 89EC                <1>     mov sp, bp
    52 000000EB 5D                  <1>     pop bp
    53                              <1> 
    54                              <1>     ; 呼び出し元へ戻る
    55 000000EC C3                  <1>     ret
    59                                  %include        "../modules/real/reboot.s"
     1                              <1> reboot:
     2                              <1>     ; 再起動の説明を出力
     3 000000ED 68[0901]E8DBFF83C4- <1>     cdecl   puts, .s0
     3 000000F5 02                  <1>
     4                              <1> 
     5                              <1> .10L:
     6                              <1>     ; キー入力待ち
     7 000000F6 B410                <1>     mov     ah, 0x10
     8 000000F8 CD16                <1>     int     0x16
     9                              <1> 
    10                              <1>     ; キー入力が空白文字ではない場合、再度キー入力待ちへ戻る
    11 000000FA 3C20                <1>     cmp     al, ' '
    12 000000FC 75F8                <1>     jne     .10L
    13                              <1> 
    14                              <1>     ; 改行出力
    15 000000FE 68[2701]E8CAFF83C4- <1>     cdecl   puts, .s1
    15 00000106 02                  <1>
    16                              <1> 
    17                              <1>     ; 再起動
    18 00000107 CD19                <1>     int     0x19
    19                              <1> 
    20                              <1> 
    21                              <1>     ; 文字列データ
    22 00000109 0A0D50757368205350- <1> .s0     db 0x0A, 0x0D, "Push SPACE Key to reboot...", 0
    22 00000112 414345204B65792074- <1>
    22 0000011B 6F207265626F6F742E- <1>
    22 00000124 2E2E00              <1>
    23 00000127 0A0D0A0D00          <1> .s1     db 0x0A, 0x0D, 0x0A, 0x0D, 0
    24                              <1> 
    60                                  %include        "../modules/real/read_chs.s"
     1                              <1> ; int read_chs(drive, sect, dst);
     2                              <1> ; @params drive :drive構造体のアドレス
     3                              <1> ; @params sect  :読み出しセクタ数
     4                              <1> ; @params dst   :読み出し先アドレス 
     5                              <1> ; @return       :読み込んだセクタ数
     6                              <1> 
     7                              <1> 
     8                              <1> ; // ****************
     9                              <1> ; // レジスタ位置関係
    10                              <1> ; // ****************
    11                              <1> ;   + 8 | dst
    12                              <1> ;   + 6 | sect
    13                              <1> ;   + 4 | drive
    14                              <1> ;   + 2 | 戻り番地
    15                              <1> ; BP+ 0 | BP
    16                              <1> ; -----------------
    17                              <1> ;   - 2 | retry = 3(読み込みリトライ回数)
    18                              <1> ;   - 4 | sect  = 0(読み込みセクタ数)
    19                              <1> 
    20                              <1> read_chs:
    21                              <1>     ; スタックフレームの構築
    22 0000012C 55                  <1>     push    bp
    23 0000012D 89E5                <1>     mov     bp, sp
    24 0000012F 6A03                <1>     push    3
    25 00000131 6A00                <1>     push    0       
    26                              <1> 
    27                              <1>     ; レジスタの保存
    28 00000133 53                  <1>     push    bx
    29 00000134 51                  <1>     push    cx
    30 00000135 52                  <1>     push    dx
    31 00000136 06                  <1>     push    es
    32 00000137 56                  <1>     push    si
    33                              <1> 
    34                              <1>     ; 処理の開始
    35 00000138 8B7604              <1>     mov     si, [bp + 4]                ; drive構造体のアドレスを取得
    36                              <1>     
    37                              <1>     ; CXレジスタの設定
    38 0000013B 8A6C02              <1>     mov     ch, [si + drive.cyln + 0]   ; CH = シリンダ番号(下位バイト)
    39 0000013E 8A4C03              <1>     mov     cl, [si + drive.cyln + 1]   ; CL = シリンダ番号(上位バイト)
    40 00000141 C0E106              <1>     shl     cl, 6                       ; CL <<= 6; 上位2ビットにシフト 0x11 -> 0x110000
    41 00000144 0A4C06              <1>     or      cl, [si + drive.sect]       ; CL |= セクタ番号(0x110000 | 0x1 = 0x110001)
    42                              <1> 
    43                              <1>     ; セクタ読み込み
    44 00000147 8A7404              <1>     mov     dh, [si + drive.head]       ; DH = ヘッド取得
    45 0000014A 8A14                <1>     mov     dl, [si + 0]                ; DL = ドライブ番号
    46 0000014C B80000              <1>     mov     ax, 0x0000                  ; AX = 0x0000
    47 0000014F 8EC0                <1>     mov     es, ax                      ; ES = セグメント
    48 00000151 8B5E08              <1>     mov     bx, [bp + 8]                ; BX = コピー先(dst)
    49                              <1> .10L:
    50 00000154 B402                <1>     mov     ah, 0x02                    ; AH = セクタ読み込み命令
    51 00000156 8A4606              <1>     mov     al, [bp + 6]                ; AL = 読み込みセクタ数(sect)
    52                              <1> 
    53 00000159 CD13                <1>     int     0x13                        ; セクタ読み込み実行: BIOS(0x13, 0x02): セクタ読み出し
    54 0000015B 7304                <1>     jnc     .11E                        ; 
    55 0000015D B000                <1>     mov     al, 0
    56 0000015F EB0C                <1>     jmp     .10E
    57                              <1> .11E:
    58 00000161 3C00                <1>     cmp     al, 0                       ; 読み込みセクタ数を0
    59 00000163 7508                <1>     jne     .10E
    60                              <1> 
    61 00000165 B80000              <1>     mov     ax, 0
    62 00000168 FF4EFE              <1>     dec     word [bp - 2]               ; リトライ回数をデクリメント
    63 0000016B 75E7                <1>     jnz     .10L                        ; 一行前のデクリメント結果が0でない場合、ループする
    64                              <1> .10E:
    65 0000016D B400                <1>     mov     ah, 0                       ; ステータス情報を破棄
    66                              <1> 
    67                              <1>     ; レジスタの復帰
    68 0000016F 5E                  <1>     pop     si
    69 00000170 07                  <1>     pop     es
    70 00000171 5A                  <1>     pop     dx
    71 00000172 59                  <1>     pop     cx
    72 00000173 5B                  <1>     pop     bx
    73                              <1> 
    74                              <1>     ; スタックフレームの破棄
    75 00000174 89EC                <1>     mov     sp, bp
    76 00000176 5D                  <1>     pop     bp
    77                              <1> 
    78 00000177 C3                  <1>     ret
    61                                  
    62                                          ; プートフラグの定義
    63 00000178 00<rept>                        times 510 - ($ - $$) db 0x00
    64 000001FE 55AA                            db 0x55, 0xAA
    65                                  
    66                                  ; リアルモード時に取得した情報
    67                                  FONT:
    68 00000200 0000                    .seg: dw 0
    69 00000202 0000                    .off: dw 0
    70                                  ACPI_DATA:
    71 00000204 00000000                .adr: dd 0
    72 00000208 00000000                .len: dd 0
    73                                  
    74                                  ; モジュール(先頭512バイト以降に配置)
    75                                  %include        "../modules/real/itoa.s"
     1                              <1> ; ******************************
     2                              <1> ; void itos(num, buff, size, radix, flag);
     3                              <1> ; (Int TO Ascii)
     4                              <1> ; -----------------
     5                              <1> ; num   : 変換対象の数値
     6                              <1> ; buff  : 保存先のバッファアドレス
     7                              <1> ; size  : 保存先のバッファサイズ
     8                              <1> ; radix : 基数(2, 8, 10, 16のいずれか)
     9                              <1> ; flag  : ビット定義フラグ
    10                              <1> ;         B2: 空白を'0'で埋める
    11                              <1> ;         B1: '+/-'符号を追加
    12                              <1> ;         B0: 値を符号付変数として扱う
    13                              <1> ; -----------------
    14                              <1> ; ******************************
    15                              <1> 
    16                              <1> ; // ****************
    17                              <1> ; // レジスタ位置関係
    18                              <1> ; // ****************
    19                              <1> ;   + 12 | flag
    20                              <1> ;   + 10 | radix
    21                              <1> ;   + 8  | size
    22                              <1> ;   + 6  | buff
    23                              <1> ;   + 4  | num
    24                              <1> ;   + 2  | 戻り番地
    25                              <1> ; BP+ 0  | BP
    26                              <1> 
    27                              <1> itoa:
    28                              <1>         ; スタックフレームの構築
    29 0000020C 55                  <1>         push    bp
    30 0000020D 89E5                <1>         mov     bp, sp
    31                              <1> 
    32                              <1>         ; レジスタの保存
    33 0000020F 50                  <1>         push    ax
    34 00000210 53                  <1>         push    bx
    35 00000211 51                  <1>         push    cx
    36 00000212 52                  <1>         push    dx
    37 00000213 56                  <1>         push    si
    38 00000214 57                  <1>         push    di
    39                              <1> 
    40                              <1>         ; 引数取得
    41 00000215 8B4604              <1>         mov     ax, [bp + 4]        ; num:  変換対象の数値
    42 00000218 8B7606              <1>         mov     si, [bp + 6]        ; buff: 変換先のバッファアドレス
    43 0000021B 8B4E08              <1>         mov     cx, [bp + 8]        ; size: バッファサイズ
    44                              <1> 
    45 0000021E 89F7                <1>         mov     di, si              ; バッファの末尾を取得: di = buff[size - 1]
    46 00000220 01CF                <1>         add     di, cx              ; di = buff + size
    47 00000222 4F                  <1>         dec     di                  ; di = di - 1
    48                              <1>         
    49 00000223 8B5E0C              <1>         mov     bx, word [bp + 12]  ; flag: 変換オプション
    50                              <1> 
    51                              <1> 
    52                              <1>         ; ------------------
    53                              <1>         ; 符号付き判定
    54                              <1>         ; ------------------
    55 00000226 F7C30100            <1>         test    bx, 0b0001  ; test <1>, <2>: 与えられた２つの値の論理積を行い、結果が0であればゼロフラグ(ZF)を立てる
    56 0000022A 7408                <1> .10Q:   je      .10E        ; je: ゼロフラグ(ZF)をチェックして、フラグが立っていれば指定ラベルへ移動する
    57 0000022C 83F800              <1>         cmp     ax, 0       ; 対象データ(ax=val)が負の値の場合、符号出力を行うフラグ(bx)をオンにする
    58 0000022F 7D03                <1>         jge     .12E
    59 00000231 83CB02              <1>         or      bx, 0b0010  ;  bx |= 2. OR演算のためB2位置が1となる(0x0000 | 0x0010 = 0x0010)
    60                              <1> .12E:
    61                              <1> .10E:
    62                              <1> 
    63                              <1>         ; ------------------
    64                              <1>         ; 符号出力判定
    65                              <1>         ; ------------------
    66 00000234 F7C30200            <1>         test    bx, 0b0010      ; if(flag == 0x0010) {
    67 00000238 7412                <1> .20Q:   je      .20E            ; 
    68 0000023A 83F800              <1>         cmp     ax, 0           ;   if(num < 0) {
    69 0000023D 7D07                <1>         jge     .22F            ;
    70                              <1> 
    71                              <1>         ; 負の値の場合            ;
    72 0000023F F7D8                <1>         neg     ax              ; NEG(2の補数)命令によって、符号を反転: num *= -1
    73 00000241 C6042D              <1>         mov     [si], byte '-'  ; 変換先のバッファアドレス(si)の先頭に'-'を付与: *buff += '-'
    74 00000244 EB05                <1>         jmp     .22E            ;
    75                              <1> 
    76                              <1>         ; 正の値の場合
    77 00000246 C6042B              <1> .22F:   mov     [si], byte '+'  ; 変換先のバッファアドレス(si)の先頭に'+'を付与: *buff += '-'
    78 00000249 EB00                <1>         jmp     .22E
    79 0000024B 49                  <1> .22E:   dec     cx              ; 符号を付与した分、残りのバッファサイズ(cx=size)を減算
    80                              <1> .20E:
    81                              <1> 
    82                              <1>         ; ------------------
    83                              <1>         ; Ascii変換
    84                              <1>         ; ------------------
    85 0000024C 8B5E0A              <1>         mov     bx, [bp + 10]           ; BX = 基数を取得
    86                              <1> .30L:
    87 0000024F BA0000              <1>         mov     dx, 0                   ; 割り算の余りはdxに代入される。なので、事前に0初期化している。
    88 00000252 F7F3                <1>         div     bx                      ; 基数(bx)で割り算(div)を行う
    89                              <1> 
    90 00000254 89D6                <1>         mov     si, dx
    91 00000256 8A94[7E02]          <1>         mov     dl, byte [.ascii + si]  ; 割り算の余りから、Asciiテーブルを参照
    92                              <1> 
    93 0000025A 8815                <1>         mov     [di], dl                ; di(変換後のバッファアドレスの末尾)にAscii文字を設定
    94 0000025C 4F                  <1>         dec     di                      ; 末尾の１つ前が次のAscii文字設定先であるため、減算(dec)する
    95                              <1> 
    96                              <1>         ; 割り算対象の値は暗黙的にax(変換対象の数値)が使用される
    97                              <1>         ; loopnz命令により、残りのバッファサイズ(cx)か変換対象(az)が0になるまで、ループを繰り返す
    98 0000025D 83F800              <1>         cmp     ax, 0
    99 00000260 E0ED                <1>         loopnz  .30L
   100                              <1> .30E:
   101                              <1> 
   102                              <1>         ; ------------------
   103                              <1>         ; 空欄を埋める
   104                              <1>         ; ------------------
   105 00000262 83F900              <1>         cmp     cx, 0                   ; バッファサイズ(cx)が残っている場合に、空欄埋めを行う
   106 00000265 740D                <1> .40Q:   je      .40E
   107 00000267 B020                <1>         mov     al, ' '
   108 00000269 837E0C04            <1>         cmp     [bp + 12], word 0b0100
   109 0000026D 7502                <1> .42Q:   jne     .42E
   110 0000026F B030                <1>         mov     al, '0'
   111                              <1> .42E:
   112 00000271 FD                  <1>         std                             ; DF=0をセット
   113 00000272 F3AA                <1>         rep stosb                       ; rep命令を置くことで、cxレジスタが0になるまで、後続のstosb命令を繰り返す。その際、stosb命令実行後にcxレジスタの減算を行う。
   114                              <1> .40E:
   115                              <1> 
   116                              <1>     ; レジスタの復帰
   117 00000274 5F                  <1>     pop di
   118 00000275 5E                  <1>     pop si
   119 00000276 5A                  <1>     pop dx
   120 00000277 59                  <1>     pop cx
   121 00000278 5B                  <1>     pop bx
   122 00000279 58                  <1>     pop ax
   123                              <1> 
   124                              <1>     ; スタックフレームの破棄
   125 0000027A 89EC                <1>     mov sp, bp
   126 0000027C 5D                  <1>     pop bp
   127                              <1> 
   128 0000027D C3                  <1>     ret
   129                              <1> 
   130 0000027E 303132333435363738- <1> .ascii  db      "0123456789ABCDEF" ;変換デーブル
   130 00000287 39414243444546      <1>
    76                                  %include        "../modules/real/get_drive_params.s"
     1                              <1> ; --------------------------------------
     2                              <1> ; int get_drive_params(drive, no);
     3                              <1> ; @params drive :drive構造体のアドレス
     4                              <1> ; @params no    :対象となるドライブ番号
     5                              <1> ; @return       :成功(0以外) or 失敗(0)
     6                              <1> ; --------------------------------------
     7                              <1> 
     8                              <1> ; ****************
     9                              <1> ; レジスタ位置関係
    10                              <1> ; ***************
    11                              <1> ;   + 6 | no
    12                              <1> ;   + 4 | drive
    13                              <1> ;   + 2 | 戻り番地
    14                              <1> ; BP+ 0 | BP
    15                              <1> ; -----------------
    16                              <1> 
    17                              <1> get_drive_params:
    18                              <1>         ; スタックフレームの構築
    19 0000028E 55                  <1>         push    bp
    20 0000028F 89E5                <1>         mov     bp, sp
    21                              <1> 
    22                              <1>         ; レジスタの保存
    23 00000291 53                  <1>         push    bx
    24 00000292 51                  <1>         push    cx
    25 00000293 06                  <1>         push    es
    26 00000294 56                  <1>         push    si
    27 00000295 57                  <1>         push    di
    28                              <1> 
    29                              <1>         ; 処理の開始
    30 00000296 8B7604              <1>         mov     si, [bp + 4]        ; drive: drive構造体のアドレス
    31 00000299 B80000              <1>         mov     ax, 0
    32 0000029C 8EC0                <1>         mov     es, ax              ; ES=0
    33 0000029E 89C7                <1>         mov     di, ax              ; DI=0
    34                              <1> 
    35                              <1>         ; ドライブパラメタを読み込む: BIOS(0x13, 0x08)
    36                              <1>         ;  - 0x13: Disk Services           : FDD、HDD、ROMディスク、RFDディスクなどにアクセスする
    37                              <1>         ;  - 0x08: Read Drive Parameters   : ドライブパラメータを読み込み
    38                              <1>         ;    (Ref: http://softwaretechnique.jp/OS_Development/Tips/Bios_Services/disk_services.html)
    39                              <1>         ;  - 取得したドライブパラメタは、CH, CL, DH, DLレジスタに設定される。
    40 000002A0 B408                <1>         mov     ah, 8
    41 000002A2 8A14                <1>         mov     dl, [si + drive.no] ; DL = ドライブ番号
    42 000002A4 CD13                <1>         int     0x13                ; BIOS(0x13, AH=0x08)
    43 000002A6 721B                <1> .10Q:   jc      .10F
    44                              <1> .10T:
    45                              <1>         ; セクタ数(AX)を取得
    46                              <1>         ; - セクタ数はCLの下位6ビットに割り当てられている(上位2ビットはシリンダ数が割り当てられている)
    47                              <1>         ; - ALはAXの下位８ビットであるため、ALに代入してもAXで使用できる
    48                              <1>         ; - セクタ数の取得は、ALと0x3FのAND演算による下位6ビット抽出によって行う
    49 000002A8 88C8                <1>         mov     al, cl
    50 000002AA 83E03F              <1>         and     ax, 0x3F
    51                              <1> 
    52                              <1>         ; シリンダ数の取得
    53                              <1>         ; - 読み込んだシリンダはCHとCLの上位2ビットに割り当てられている(以下の括弧で囲われているビットが対象)
    54                              <1>         ;   CH                           CL
    55                              <1>         ;   [(7),(6),(5),(4),(3),(2),(1)][(*7),(*6),5,4,3,2,1]
    56                              <1>         ;
    57                              <1>         ; - シリンダ取得では、上のCH,CL内のデータを以下の並びにする
    58                              <1>         ;   [(*7),(*6),(7),(6),(5),(4),(3),(2),(1)]
    59 000002AD C0E906              <1>         shr     cl, 6               ; CLを6ビット分の右シフト
    60 000002B0 C1C908              <1>         ror     cx, 8               ; CX(CH+CL)を8ビット分の右回転
    61 000002B3 41                  <1>         inc     cx                  ; シリンダ数は0始まりであるため、1加算する
    62                              <1> 
    63                              <1>         ; ヘッド数の取得
    64                              <1>         ; - ヘッド数は、DHに割り当てられている
    65 000002B4 0FB6DE              <1>         movzx   bx, dh              ; movzx命令で上位1バイト追加して取得する
    66 000002B7 43                  <1>         inc     bx                  ; ヘッド数は0始まりであるため、1加算する
    67                              <1> 
    68                              <1>         ; 取得したドライブパラメタを、引数のdrive構造体に設定
    69 000002B8 894C02              <1>         mov [si + drive.cyln], cx
    70 000002BB 895C04              <1>         mov [si + drive.head], bx
    71 000002BE 894406              <1>         mov [si + drive.sect], ax
    72                              <1> 
    73 000002C1 EB03                <1>         jmp .10E
    74                              <1> .10F:
    75                              <1>         ; 読み込み失敗した場合、戻り値を0(=失敗)に設定
    76 000002C3 B80000              <1>         mov     ax, 0
    77                              <1> .10E:
    78                              <1>         ; レジスタの復帰
    79 000002C6 5F                  <1>         pop di
    80 000002C7 5E                  <1>         pop si
    81 000002C8 07                  <1>         pop es
    82 000002C9 59                  <1>         pop cx
    83 000002CA 5B                  <1>         pop bx
    84                              <1> 
    85                              <1>         ; スタックフレームの破棄
    86 000002CB 89EC                <1>         mov sp, bp
    87 000002CD 5D                  <1>         pop bp
    88                              <1> 
    89 000002CE C3                  <1>         ret
    77                                  %include        "../modules/real/get_font_adr.s"
     1                              <1> ; --------------------------------------
     2                              <1> ; int get_font_adr(adr);
     3                              <1> ; @params adr   : フォントアドレスの格納位置
     4                              <1> ; @return       : なし
     5                              <1> ; --------------------------------------
     6                              <1> 
     7                              <1> ; ****************
     8                              <1> ; レジスタ位置関係
     9                              <1> ; ***************
    10                              <1> ;   + 4 | adr
    11                              <1> ;   + 2 | 戻り番地
    12                              <1> ; BP+ 0 | BP
    13                              <1> ; -----------------
    14                              <1> 
    15                              <1> get_font_adr:
    16                              <1>         ; スタックフレームの構築
    17 000002CF 55                  <1>         push bp
    18 000002D0 89E5                <1>         mov bp, sp
    19                              <1> 
    20                              <1>         ; レジスタの保存
    21 000002D2 50                  <1>         push ax
    22 000002D3 53                  <1>         push bx
    23 000002D4 56                  <1>         push si
    24 000002D5 06                  <1>         push es
    25 000002D6 55                  <1>         push bp
    26                              <1> 
    27                              <1>         ; 引数を取得
    28 000002D7 8B7604              <1>         mov si, [bp + 4]
    29                              <1> 
    30                              <1>         ; フォントアドレスの取得
    31                              <1>         ; - AXとBHに指定の値を設定することで、フォントアドレスが取得できる
    32                              <1>         ;   Ref: http://hp.vector.co.jp/authors/VA003720/lpproj/int10h/i101130.htm
    33 000002DA B83011              <1>         mov ax, 0x1130  ; 0x1130:フォントアドレス取得
    34 000002DD B706                <1>         mov bh, 0x06    ; 0x06  :8x16ドットサイズ 
    35 000002DF CD10                <1>         int 10h
    36                              <1> 
    37                              <1>         ; フォントアドレスを保存
    38 000002E1 8C04                <1>         mov [si + 0], es    ; セグメント
    39 000002E3 896C02              <1>         mov [si + 2], bp    ; オフセット
    40                              <1> 
    41                              <1>         ; レジスタの復帰
    42 000002E6 5D                  <1>         pop bp
    43 000002E7 07                  <1>         pop es
    44 000002E8 5E                  <1>         pop si
    45 000002E9 5B                  <1>         pop bx
    46 000002EA 58                  <1>         pop ax
    47                              <1> 
    48                              <1>         ; スタックフレームの破棄
    49 000002EB 89EC                <1>         mov sp, bp
    50 000002ED 5D                  <1>         pop bp
    51                              <1> 
    52 000002EE C3                  <1>         ret
    78                                  %include        "../modules/real/get_mem_info.s"
     1                              <1> ; --------------------------------------
     2                              <1> ; void get_mem_info();
     3                              <1> ; @return       : なし
     4                              <1> ; --------------------------------------
     5                              <1> 
     6                              <1> ; ****************
     7                              <1> ; レジスタ位置関係
     8                              <1> ; ***************
     9                              <1> ;   + 2 | 戻り番地
    10                              <1> ; BP+ 0 | BP
    11                              <1> ; -----------------
    12                              <1> 
    13                              <1> get_mem_info:
    14                              <1>         ; レジスタ保存
    15                              <1>         ; eax: 32bit(ax: 16bit, rax: 64bit)
    16 000002EF 6650                <1>         push eax
    17 000002F1 6653                <1>         push ebx
    18 000002F3 6651                <1>         push ecx
    19 000002F5 6652                <1>         push edx
    20 000002F7 56                  <1>         push si
    21 000002F8 57                  <1>         push di
    22 000002F9 55                  <1>         push bp
    23                              <1> 
    24 000002FA 00<rept>            <1> ALIGN 4, db 0
    25 000002FC 00<rept>            <1> .b0:    times E820_RECORD_SIZE db 0
    26 00000310 68[A403]E8B8FD83C4- <1>         cdecl puts, .s0
    26 00000318 02                  <1>
    27                              <1>         
    28                              <1>         ; メモリ情報取得開始
    29 00000319 BD0000              <1>         mov bp, 0
    30 0000031C 66BB00000000        <1>         mov ebx, 0
    31                              <1> .10L:
    32                              <1>         ; メモリ情報を取得するBIOSコール
    33 00000322 66B820E80000        <1>         mov eax, 0x0000E820         ; EAX   = 0xE820(要求コマンド)
    34                              <1>                                     ; EBX   = インデックス(0)
    35 00000328 66B914000000        <1>         mov ecx, E820_RECORD_SIZE   ; ECX   = 要求バイト数
    36 0000032E 66BA50414D53        <1>         mov edx, 'PAMS'             ; EDX   = SMAP
    37 00000334 BF[FC02]            <1>         mov di, .b0                 ; ES:DI = バッファ
    38 00000337 CD15                <1>         int 0x15                    ; BIOS(0x15, 0xE820)
    39                              <1> 
    40                              <1>         ; メモリ情報取得が未対応のBIOSの場合(EAXにSMAPが設定されないはず)
    41 00000339 663D50414D53        <1>         cmp eax, 'PAMS'
    42 0000033F 7402                <1>         je  .12E
    43 00000341 EB4C                <1>         jmp .10E
    44                              <1> .12E:
    45                              <1>         ; BIOSコールに失敗した場合(エラー時はCFで判断可能)
    46 00000343 7302                <1>         jnc .14E
    47 00000345 EB48                <1>         jmp .10E
    48                              <1> .14E:
    49                              <1>         ; 1コード分のメモリ情報を表示
    50 00000347 57E8E40083C402      <1>         cdecl put_mem_info, di
    51                              <1> 
    52                              <1>         ; ACPI dataのアドレスを取得
    53 0000034E 668B4510            <1>         mov eax, [di + 16]          ; EAX: レコードタイプ
    54 00000352 6683F803            <1>         cmp eax, 3                  ; EAX = 3(ACPI data)の場合
    55 00000356 750F                <1>         jne .15E
    56                              <1> 
    57 00000358 668B05              <1>         mov eax, [di + 0]           ; メモリ領域のBASEアドレスの保存
    58 0000035B 66A3[0402]          <1>         mov [ACPI_DATA.adr], eax
    59                              <1> 
    60 0000035F 668B4508            <1>         mov eax, [di + 8]           ; メモリ領域のサイズの保存
    61 00000363 66A3[0802]          <1>         mov [ACPI_DATA.len], eax
    62                              <1> .15E:
    63 00000367 6683FB00            <1>         cmp ebx, 0
    64 0000036B 741C                <1>         jz  .16E
    65                              <1>         
    66 0000036D 45                  <1>         inc bp
    67 0000036E 83E507              <1>         and bp, 0x07
    68 00000371 7516                <1>         jnz .16E
    69                              <1>         
    70 00000373 68[1704]E855FD83C4- <1>         cdecl puts, .s2
    70 0000037B 02                  <1>
    71                              <1> 
    72 0000037C B410                <1>         mov ah, 0x10
    73 0000037E CD16                <1>         int 0x16
    74                              <1>         
    75 00000380 68[2204]E848FD83C4- <1>         cdecl puts, .s3
    75 00000388 02                  <1>
    76                              <1> .16E:
    77 00000389 6683FB00            <1>         cmp ebx, 0
    78 0000038D 7593                <1>         jne .10L
    79                              <1> .10E:
    80 0000038F 68[E703]E839FD83C4- <1>         cdecl puts, .s1
    80 00000397 02                  <1>
    81                              <1>         
    82                              <1> ; レジスタ復帰
    83 00000398 5D                  <1>         pop bp
    84 00000399 5F                  <1>         pop di
    85 0000039A 5E                  <1>         pop si
    86 0000039B 665A                <1>         pop edx
    87 0000039D 6659                <1>         pop ecx
    88 0000039F 665B                <1>         pop ebx
    89 000003A1 6658                <1>         pop eax
    90                              <1> 
    91 000003A3 C3                  <1>         ret
    92                              <1> 
    93                              <1> ; データ定義
    94 000003A4 2045383230204D656D- <1> .s0:	db " E820 Memory Map:", 0x0A, 0x0D
    94 000003AD 6F7279204D61703A0A- <1>
    94 000003B6 0D                  <1>
    95 000003B7 20426173655F5F5F5F- <1> 	db " Base_____________ Length___________ Type____", 0x0A, 0x0D, 0
    95 000003C0 5F5F5F5F5F5F5F5F5F- <1>
    95 000003C9 204C656E6774685F5F- <1>
    95 000003D2 5F5F5F5F5F5F5F5F5F- <1>
    95 000003DB 20547970655F5F5F5F- <1>
    95 000003E4 0A0D00              <1>
    96 000003E7 202D2D2D2D2D2D2D2D- <1> .s1:	db " ----------------- ----------------- --------", 0x0A, 0x0D, 0
    96 000003F0 2D2D2D2D2D2D2D2D2D- <1>
    96 000003F9 202D2D2D2D2D2D2D2D- <1>
    96 00000402 2D2D2D2D2D2D2D2D2D- <1>
    96 0000040B 202D2D2D2D2D2D2D2D- <1>
    96 00000414 0A0D00              <1>
    97 00000417 203C6D6F72652E2E2E- <1> .s2:    db " <more...>", 0
    97 00000420 3E00                <1>
    98 00000422 0D2020202020202020- <1> .s3:    db 0x0D, "          ", 0x0D, 0
    98 0000042B 20200D00            <1>
    79                                  %include        "../modules/real/put_mem_info.s"
     1                              <1> ; --------------------------------------
     2                              <1> ; int put_mem_info(adr);
     3                              <1> ; @params adr   :バッファアドレス
     4                              <1> ; @return       :成功(0以外) or 失敗(0)
     5                              <1> ; --------------------------------------
     6                              <1> 
     7                              <1> ; ****************
     8                              <1> ; レジスタ位置関係
     9                              <1> ; ***************
    10                              <1> ;   + 4 | adr
    11                              <1> ;   + 2 | 戻り番地
    12                              <1> ; BP+ 0 | BP
    13                              <1> ; -----------------
    14                              <1> 
    15                              <1> put_mem_info:
    16                              <1>     ; スタックフレームの構築
    17 0000042F 55                  <1>     push bp
    18 00000430 89E5                <1>     mov  bp, sp
    19                              <1> 
    20                              <1>     ; レジスタの保存
    21 00000432 53                  <1>     push bx
    22 00000433 56                  <1>     push si
    23                              <1> 
    24                              <1>     ; 引数の取得
    25 00000434 8B7604              <1>     mov si, [bp + 4]
    26                              <1> 
    27                              <1>     ; Baseアドレス(64bit)
    28 00000437 6A046A106A0468-     <1>     cdecl itoa, word [si + 6], .p2 + 0, 4, 16, 0b0100
    28 0000043E [0E05]FF7406E8C6FD- <1>
    28 00000446 83C40A              <1>
    29 00000449 6A046A106A0468-     <1>     cdecl itoa, word [si + 4], .p2 + 4, 4, 16, 0b0100
    29 00000450 [1205]FF7404E8B4FD- <1>
    29 00000458 83C40A              <1>
    30 0000045B 6A046A106A0468-     <1>     cdecl itoa, word [si + 2], .p3 + 0, 4, 16, 0b0100
    30 00000462 [1705]FF7402E8A2FD- <1>
    30 0000046A 83C40A              <1>
    31 0000046D 6A046A106A0468-     <1>     cdecl itoa, word [si + 0], .p3 + 4, 4, 16, 0b0100
    31 00000474 [1B05]FF34E891FD83- <1>
    31 0000047C C40A                <1>
    32                              <1> 
    33                              <1>     ; データ長(64bit)
    34 0000047E 6A046A106A0468-     <1>     cdecl itoa, word [si + 14], .p4 + 0, 4, 16, 0b0100
    34 00000485 [2005]FF740EE87FFD- <1>
    34 0000048D 83C40A              <1>
    35 00000490 6A046A106A0468-     <1>     cdecl itoa, word [si + 12], .p4 + 4, 4, 16, 0b0100
    35 00000497 [2405]FF740CE86DFD- <1>
    35 0000049F 83C40A              <1>
    36 000004A2 6A046A106A0468-     <1>     cdecl itoa, word [si + 10], .p5 + 0, 4, 16, 0b0100
    36 000004A9 [2905]FF740AE85BFD- <1>
    36 000004B1 83C40A              <1>
    37 000004B4 6A046A106A0468-     <1>     cdecl itoa, word [si +  8], .p5 + 4, 4, 16, 0b0100
    37 000004BB [2D05]FF7408E849FD- <1>
    37 000004C3 83C40A              <1>
    38                              <1> 
    39                              <1>     ; Type(32bit)
    40 000004C6 6A046A106A0468-     <1>     cdecl itoa, word [si + 18], .p6 + 0, 4, 16, 0b0100
    40 000004CD [3205]FF7412E837FD- <1>
    40 000004D5 83C40A              <1>
    41 000004D8 6A046A106A0468-     <1>     cdecl itoa, word [si + 16], .p6 + 4, 4, 16, 0b0100
    41 000004DF [3605]FF7410E825FD- <1>
    41 000004E7 83C40A              <1>
    42                              <1> 
    43 000004EA 68[0D05]E8DEFB83C4- <1>     cdecl puts, .s1
    43 000004F2 02                  <1>
    44                              <1> 
    45                              <1>     ; Typeを文字列として表示
    46 000004F3 8B5C10              <1>     mov bx, [si + 16]
    47 000004F6 83E307              <1>     and bx, 0x07            ; 0010 & 0111 = 0010
    48 000004F9 D1E3                <1>     shl bx, 1               ; 0010 -> 0100(=4)
    49 000004FB 81C3[8905]          <1>     add bx, .t0             ; レコード情報テーブルの先頭アドレスを加算 -> 指定レコードの情報が取得できる
    50 000004FF FF37E8CAFB83C402    <1>     cdecl puts, word [bx]
    51                              <1> 
    52                              <1>     ; レジスタの復帰
    53 00000507 5E                  <1>     pop si
    54 00000508 5B                  <1>     pop bx
    55                              <1> 
    56                              <1>     ; スタックフレームの破棄
    57 00000509 89EC                <1>     mov sp, bp
    58 0000050B 5D                  <1>     pop bp
    59                              <1> 
    60 0000050C C3                  <1>     ret
    61                              <1> 
    62                              <1> ; 定数定義
    63 0000050D 20                  <1> .s1:    db " "
    64 0000050E 5A5A5A5A5A5A5A5A5F  <1> .p2:    db "ZZZZZZZZ_"
    65 00000517 5A5A5A5A5A5A5A5A20  <1> .p3:    db "ZZZZZZZZ "
    66 00000520 5A5A5A5A5A5A5A5A5F  <1> .p4:    db "ZZZZZZZZ_"
    67 00000529 5A5A5A5A5A5A5A5A20  <1> .p5:    db "ZZZZZZZZ "
    68 00000532 5A5A5A5A5A5A5A5A00  <1> .p6:    db "ZZZZZZZZ", 0
    69                              <1> 
    70 0000053B 28556E6B6E6F776E29- <1> .s4:    db "(Unknown)", 0x0A, 0x0D, 0
    70 00000544 0A0D00              <1>
    71 00000547 28757361626C65290A- <1> .s5:    db "(usable)", 0x0A, 0x0D, 0
    71 00000550 0D00                <1>
    72 00000552 287265736572766564- <1> .s6:    db "(reserved)", 0x0A, 0x0D, 0
    72 0000055B 290A0D00            <1>
    73 0000055F 284143504920646174- <1> .s7:    db "(ACPI data)", 0x0A, 0x0D, 0
    73 00000568 61290A0D00          <1>
    74 0000056D 2841435049204E5653- <1> .s8:    db "(ACPI NVS)", 0x0A, 0x0D, 0
    74 00000576 290A0D00            <1>
    75 0000057A 28626164206D656D6F- <1> .s9:    db "(bad memory)", 0x0A, 0x0D, 0
    75 00000583 7279290A0D00        <1>
    76                              <1> 
    77                              <1>         ; dw(data double byte): 2バイトデータとして定義する
    78                              <1>         ; 要素間のアドレス差は2byteなので、+2すると次要素になる
    79 00000589 [3B05][4705][5205]- <1> .t0:    dw .s4, .s5, .s6, .s7, .s8, .s9, .s4, .s4
    79 0000058F [5F05][6D05][7A05]- <1>
    79 00000595 [3B05][3B05]        <1>
    80                                  
    81                                  stage_2:
    82 00000599 68[1306]E82FFB83C4-             cdecl   puts, .s0
    82 000005A1 02                 
    83                                  
    84                                          ; ドライブ情報を取得
    85 000005A2 68[C600]E8E6FC83C4-             cdecl   get_drive_params, BOOT
    85 000005AA 02                 
    86 000005AB 83F800                          cmp     ax, 0
    87 000005AE 750C                    .10Q:   jne     .10E
    88 000005B0 68[4A06]E818FB83C4-     .10T:   cdecl   puts, .e0
    88 000005B8 02                 
    89 000005B9 E831FB                          call    reboot
    90                                  .10E:
    91                                  
    92                                          ; ドライブ情報を表示
    93                                          ; 以下が表示される
    94                                          ; Drive:0x80, C:0x0014, H:0x02, D:0x10
    95                                          ; ドライブ番号:128, シリンダ数:20, ヘッド数:2, セクタ数:16
    96 000005BC A1[C600]                        mov     ax, [BOOT + drive.no]
    97 000005BF 6A046A106A0268-                 cdecl   itoa, ax, .p1, 2, 16, 0b0100
    97 000005C6 [2B06]50E840FC83C4-
    97 000005CE 0A                 
    98 000005CF A1[C800]                        mov     ax, [BOOT + drive.cyln]
    99 000005D2 6A046A106A0468-                 cdecl   itoa, ax, .p2, 4, 16, 0b0100
    99 000005D9 [3306]50E82DFC83C4-
    99 000005E1 0A                 
   100 000005E2 A1[CA00]                        mov     ax, [BOOT + drive.head]
   101 000005E5 6A046A106A0268-                 cdecl   itoa, ax, .p3, 2, 16, 0b0100
   101 000005EC [3D06]50E81AFC83C4-
   101 000005F4 0A                 
   102 000005F5 A1[CC00]                        mov     ax, [BOOT + drive.sect]
   103 000005F8 6A046A106A0268-                 cdecl   itoa, ax, .p4, 2, 16, 0b0100
   103 000005FF [4506]50E807FC83C4-
   103 00000607 0A                 
   104 00000608 68[2206]E8C0FA83C4-             cdecl   puts, .s1
   104 00000610 02                 
   105                                  
   106                                          ; 処理の終了
   107 00000611 EB53                            jmp     stage_3rd
   108                                  
   109                                  ; データ定義
   110 00000613 326E64207374616765-     .s0     db      "2nd stage...", 0x0A, 0x0D, 0
   110 0000061C 2E2E2E0A0D00       
   111                                  
   112 00000622 2044726976653A3078      .s1     db      " Drive:0x"
   113 0000062B 20202C20433A3078        .p1     db      "  , C:0x"
   114 00000633 202020202C20483A30-     .p2     db      "    , H:0x"
   114 0000063C 78                 
   115 0000063D 20202C20533A3078        .p3     db      "  , S:0x"
   116 00000645 20200A0D00              .p4     db      "  ", 0x0A, 0x0D, 0
   117                                  
   118 0000064A 43616E277420676574-     .e0     db      "Can't get drive parameter. ", 0
   118 00000653 206472697665207061-
   118 0000065C 72616D657465722E20-
   118 00000665 00                 
   119                                  
   120                                  stage_3rd:
   121 00000666 68[E906]E862FA83C4-             cdecl   puts, .s0
   121 0000066E 02                 
   122                                  
   123                                          ; フォントアドレスを取得(BIOSが利用するフォント)
   124 0000066F 68[0002]E85AFC83C4-             cdecl   get_font_adr, FONT
   124 00000677 02                 
   125                                  
   126                                          ; フォントアドレス表示
   127 00000678 6A046A106A0468-                 cdecl   itoa, word [FONT.seg], .p1, 4, 16, 0b0100
   127 0000067F [0507]FF36[0002]E8-
   127 00000686 84FB83C40A         
   128 0000068B 6A046A106A0468-                 cdecl   itoa, word [FONT.off], .p2, 4, 16, 0b0100
   128 00000692 [0A07]FF36[0202]E8-
   128 00000699 71FB83C40A         
   129 0000069E 68[F806]E82AFA83C4-             cdecl   puts, .s1
   129 000006A6 02                 
   130                                  
   131                                          ; メモリ情報の取得と表示
   132 000006A7 68[0402]E842FC83C4-             cdecl   get_mem_info, ACPI_DATA
   132 000006AF 02                 
   133                                  
   134 000006B0 66A1[0402]                      mov     eax, [ACPI_DATA.adr]
   135 000006B4 6683F800                        cmp     eax, 0
   136 000006B8 742D                            je      .10E
   137                                  
   138 000006BA 6A046A106A0468-                 cdecl   itoa, ax, .p4, 4, 16, 0b0100
   138 000006C1 [2407]50E845FB83C4-
   138 000006C9 0A                 
   139 000006CA 66C1E810                        shr     eax, 16
   140 000006CE 6A046A106A0468-                 cdecl   itoa, ax, .p3, 4, 16, 0b0100
   140 000006D5 [1F07]50E831FB83C4-
   140 000006DD 0A                 
   141 000006DE 68[1407]E8EAF983C4-             cdecl   puts, .s2
   141 000006E6 02                 
   142                                  .10E:
   143                                          ; 処理終了
   144 000006E7 EBFE                            jmp     $
   145                                  
   146                                  ; データ
   147 000006E9 336E64207374616765-     .s0     db "3nd stage...", 0x0A, 0x0D, 0
   147 000006F2 2E2E2E0A0D00       
   148 000006F8 20466F6E7420416472-     .s1:    db " Font Adress="
   148 00000701 6573733D           
   149 00000705 5A5A5A5A3A              .p1:    db "ZZZZ:"
   150 0000070A 5A5A5A5A0A0D00          .p2:    db "ZZZZ", 0x0A, 0x0D, 0
   151 00000711 0A0D00                          db 0x0A, 0x0D, 0
   152                                  
   153 00000714 204143504920646174-     .s2:    db " ACPI data="
   153 0000071D 613D               
   154 0000071F 5A5A5A5A3A              .p3:    db "ZZZZ:"
   155 00000724 5A5A5A5A0A0D00          .p4:    db "ZZZZ", 0x0A, 0x0D, 0
   156                                  
   157                                          ; ブートプログラムを8Kバイトとして定義
   158 0000072B 00<rept>                        times BOOT_SIZE - ($ - $$) db 0        ; 8Kバイト

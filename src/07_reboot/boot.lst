     1                                  ; **********************************************
     2                                  ; put_c
     3                                  ; put_s関数を呼び出して、文字列出力を行う
     4                                  ; **********************************************
     5                                  
     6                                          BOOT_LOAD       equ     0x7C00
     7                                          ORG     BOOT_LOAD
     8                                  
     9                                  %include "../include/macro.s"
     1                              <1> ; %macro <マクロ名> <引数の数>
     2                              <1> ; 1-*: 1つ以上の引数が指定されることを示す
     3                              <1> ; .nolist: マクロのリスト出力を抑止
     4                              <1> %macro  cdecl 1-*.nolist
     5                              <1> 
     6                              <1>     ; -------------------------------------------------
     7                              <1>     ; 引数リストから、呼び出し関数の引数を末尾から順にpushする
     8                              <1>     ; -------------------------------------------------
     9                              <1>     ; %rep <number>: %rep -> %endrepの間を指定回数分ループする
    10                              <1>     ; %0 - 1: 呼び出し関数への引数の数(%0は引数の数を表す。引数の数から、呼び出し関数そのものを数から引くと呼び出し関数への引数の数となる)
    11                              <1>     %rep    %0 - 1
    12                              <1>         ; 引数リストの末尾の値をpushする
    13                              <1>         ; %{-1:-1}: 引数リストの末尾を表す
    14                              <1>         push    %{-1:-1}
    15                              <1> 
    16                              <1>         ; %rotate: 引数リストを指定した数だけずらす
    17                              <1>         ; 今回は末尾から引数をpushしたいので、負の数を指定し右方向へ動かす
    18                              <1>         ; ※動作例
    19                              <1>         ; [1, 2, 3, 4] -> (%rotate -1) -> [4, 1, 2, 3]
    20                              <1>         %rotate -1
    21                              <1>     %endrep
    22                              <1> 
    23                              <1>     ; 引数リストの順番を元に戻す
    24                              <1>     %rotate - 1
    25                              <1> 
    26                              <1>     ; 関数呼び出し
    27                              <1>     call    %1
    28                              <1>     
    29                              <1>     ; 引数が与えられている場合
    30                              <1>     %if 1 < %0
    31                              <1>         ; 呼び出し関数への引数分だけスタックの破棄(スタックポインタ(SP)の調整)
    32                              <1>         ; __BITS__: ビットモード判定(実行環境に応じた値(16 or 32 or 64)が得られる)
    33                              <1>         ; ビットモードを3ビット分右にシフト(1/8)すると、バイトサイズが得られる
    34                              <1>         ; * 16ビットモード: 2バイト
    35                              <1>         ; * 32ビットモード: 4バイト
    36                              <1>         ; * 64ビットモード: 8バイト
    37                              <1>         add sp, (__BITS__ >> 3) * (%0 - 1)
    38                              <1>     %endif
    39                              <1> 
    40                              <1> %endmacro
    10                                  
    11                                  entry:
    12 00000000 EB58                            jmp     ipl
    13 00000002 90<rept>                        times 90 - ($ - $$) db 0x90
    14                                  ipl:
    15 0000005A FA                              cli
    16 0000005B B80000                          mov     ax, 0x0000      ; Accumulate(蓄積) Register = 0x0000
    17 0000005E 8ED8                            mov     ds, ax          ; Data Segment  = 0x0000
    18 00000060 8EC0                            mov     es, ax          ; Extra Segment = 0x0000
    19 00000062 8ED0                            mov     ss, ax          ; Stack Segment = 0x0000
    20 00000064 BC007C                          mov     sp, BOOT_LOAD   ; Stack Point   = 0x7C00
    21                                  
    22 00000067 FB                              sti
    23                                  
    24 00000068 8816[8A00]                      mov     [BOOT.DRIVE], dl
    25 0000006C E8BE00                          cdecl   reboot
    26                                  
    27 0000006F EBFE                            jmp     $
    28                                  
    29                                  ;データ定義
    30                                  ; 0x0A(LF.カーソル位置を一行下げる), 0x0D(CR.カーソル位置を左端に移動する)
    31 00000071 426F6F74696E672E2E-     .s0     db      "Booting....", 0x0A, 0x0D, 0
    31 0000007A 2E2E0A0D00         
    32 0000007F 2D2D2D2D2D2D2D2D0A-     .s1     db      "--------", 0x0A, 0x0D, 0
    32 00000088 0D00               
    33                                  
    34                                  ; ALIGNディレクティブ。データを2バイト境界で配置するように指示
    35                                  ALIGN 2, db 0
    36                                  
    37                                  ; ブートドライブに関する情報
    38                                  BOOT:
    39 0000008A 0000                    .DRIVE:         dw 0    ; ドライブ番号
    40                                  
    41                                  ; モジュール読み込み
    42                                  %include        "../modules/real/puts.s"
     1                              <1> ; ******************************
     2                              <1> ; void puts(str);
     3                              <1> ; -----------------
     4                              <1> ; str: 文字列のアドレス
     5                              <1> ; -----------------
     6                              <1> ; ******************************
     7                              <1> 
     8                              <1> ; // ****************
     9                              <1> ; // レジスタ位置関係
    10                              <1> ; // ****************
    11                              <1> ;   + 4 | str
    12                              <1> ;   + 2 | 戻り番地
    13                              <1> ; BP+ 0 | BP
    14                              <1> 
    15                              <1> puts:
    16                              <1>     ; スタックフレームの構築
    17 0000008C 55                  <1>     push    bp
    18 0000008D 89E5                <1>     mov     bp, sp
    19                              <1> 
    20                              <1>     ; レジスタの保存
    21 0000008F 50                  <1>     push    ax              ;AX: Accumulate Register
    22 00000090 53                  <1>     push    bx              ;BX: Base Register
    23 00000091 56                  <1>     push    si              ;SI: Source Register。ストリーム操作コマンド（たとえば MOV命令）でのソース（入力元）へのポインタとして使用
    24                              <1> 
    25                              <1>     ; 引数取得
    26 00000092 8B7604              <1>     mov     si, [bp + 4]
    27                              <1> 
    28                              <1>     ; 処理開始
    29 00000095 B40E                <1>     mov     ah, 0x0E        ; AH(AXの上位(Hight)8bit)に、テレタイプ式1文字出力を設定
    30 00000097 BB0000              <1>     mov     bx, 0x0000      ; ページ番号と文字色を0に設定
    31 0000009A FC                  <1>     cld                     ; Clear Direction Flag. DF=0で+方向に設定
    32                              <1> .10L:
    33                              <1>     ; LODSB命令: SIレジスタに指定されたアドレスから1バイト分のデータをALレジスタに読み込む。
    34                              <1>     ; そして、SIレジスタの値を1加算(or減算)を行う。今回はDF=0のため加算される)
    35 0000009B AC                  <1>     lodsb
    36                              <1>     
    37                              <1>     ; ALレジスタを比較し0x00(終端文字)の場合は処理終了
    38                              <1>     ; 終端文字ではない場合は、該当文字の文字を出力し、処理を繰り返す
    39 0000009C 3C00                <1>     cmp     al, 0
    40 0000009E 7404                <1>     je      .10E
    41 000000A0 CD10                <1>     int     0x10            ; ビデオBIOSコール(INT10)
    42 000000A2 EBF7                <1>     jmp     .10L
    43                              <1> .10E:
    44                              <1> 
    45                              <1>     ; レジスタの復帰
    46 000000A4 5E                  <1>     pop si
    47 000000A5 5B                  <1>     pop bx
    48 000000A6 58                  <1>     pop ax
    49                              <1> 
    50                              <1>     ; スタックフレームの破棄
    51 000000A7 89EC                <1>     mov sp, bp
    52 000000A9 5D                  <1>     pop bp
    53                              <1> 
    54                              <1>     ; 呼び出し元へ戻る
    55 000000AA C3                  <1>     ret
    43                                  %include        "../modules/real/itoa.s"
     1                              <1> ; ******************************
     2                              <1> ; void itos(num, buff, size, radix, flag);
     3                              <1> ; (Int TO Ascii)
     4                              <1> ; -----------------
     5                              <1> ; num   : 変換対象の数値
     6                              <1> ; buff  : 保存先のバッファアドレス
     7                              <1> ; size  : 保存先のバッファサイズ
     8                              <1> ; radix : 基数(2, 8, 10, 16のいずれか)
     9                              <1> ; flag  : ビット定義フラグ
    10                              <1> ;         B2: 空白を'0'で埋める
    11                              <1> ;         B1: '+/-'符号を追加
    12                              <1> ;         B0: 値を符号付変数として扱う
    13                              <1> ; -----------------
    14                              <1> ; ******************************
    15                              <1> 
    16                              <1> ; // ****************
    17                              <1> ; // レジスタ位置関係
    18                              <1> ; // ****************
    19                              <1> ;   + 12 | flag
    20                              <1> ;   + 10 | radix
    21                              <1> ;   + 8  | size
    22                              <1> ;   + 6  | buff
    23                              <1> ;   + 4  | num
    24                              <1> ;   + 2  | 戻り番地
    25                              <1> ; BP+ 0  | BP
    26                              <1> 
    27                              <1> itoa:
    28                              <1>         ; スタックフレームの構築
    29 000000AB 55                  <1>         push    bp
    30 000000AC 89E5                <1>         mov     bp, sp
    31                              <1> 
    32                              <1>         ; レジスタの保存
    33 000000AE 50                  <1>         push    ax
    34 000000AF 53                  <1>         push    bx
    35 000000B0 51                  <1>         push    cx
    36 000000B1 52                  <1>         push    dx
    37 000000B2 56                  <1>         push    si
    38 000000B3 57                  <1>         push    di
    39                              <1> 
    40                              <1>         ; 引数取得
    41 000000B4 8B4604              <1>         mov     ax, [bp + 4]        ; num:  変換対象の数値
    42 000000B7 8B7606              <1>         mov     si, [bp + 6]        ; buff: 変換先のバッファアドレス
    43 000000BA 8B4E08              <1>         mov     cx, [bp + 8]        ; size: バッファサイズ
    44                              <1> 
    45 000000BD 89F7                <1>         mov     di, si              ; バッファの末尾を取得: di = buff[size - 1]
    46 000000BF 01CF                <1>         add     di, cx              ; di = buff + size
    47 000000C1 4F                  <1>         dec     di                  ; di = di - 1
    48                              <1>         
    49 000000C2 8B5E0C              <1>         mov     bx, word [bp + 12]  ; flag: 変換オプション
    50                              <1> 
    51                              <1> 
    52                              <1>         ; ------------------
    53                              <1>         ; 符号付き判定
    54                              <1>         ; ------------------
    55 000000C5 F7C30100            <1>         test    bx, 0b0001  ; test <1>, <2>: 与えられた２つの値の論理積を行い、結果が0であればゼロフラグ(ZF)を立てる
    56 000000C9 7408                <1> .10Q:   je      .10E        ; je: ゼロフラグ(ZF)をチェックして、フラグが立っていれば指定ラベルへ移動する
    57 000000CB 83F800              <1>         cmp     ax, 0       ; 対象データ(ax=val)が負の値の場合、符号出力を行うフラグ(bx)をオンにする
    58 000000CE 7D03                <1>         jge     .12E
    59 000000D0 83CB02              <1>         or      bx, 0b0010  ;  bx |= 2. OR演算のためB2位置が1となる(0x0000 | 0x0010 = 0x0010)
    60                              <1> .12E:
    61                              <1> .10E:
    62                              <1> 
    63                              <1>         ; ------------------
    64                              <1>         ; 符号出力判定
    65                              <1>         ; ------------------
    66 000000D3 F7C30200            <1>         test    bx, 0b0010      ; if(flag == 0x0010) {
    67 000000D7 7412                <1> .20Q:   je      .20E            ; 
    68 000000D9 83F800              <1>         cmp     ax, 0           ;   if(num < 0) {
    69 000000DC 7D07                <1>         jge     .22F            ;
    70                              <1> 
    71                              <1>         ; 負の値の場合            ;
    72 000000DE F7D8                <1>         neg     ax              ; NEG(2の補数)命令によって、符号を反転: num *= -1
    73 000000E0 C6042D              <1>         mov     [si], byte '-'  ; 変換先のバッファアドレス(si)の先頭に'-'を付与: *buff += '-'
    74 000000E3 EB05                <1>         jmp     .22E            ;
    75                              <1> 
    76                              <1>         ; 正の値の場合
    77 000000E5 C6042B              <1> .22F:   mov     [si], byte '+'  ; 変換先のバッファアドレス(si)の先頭に'+'を付与: *buff += '-'
    78 000000E8 EB00                <1>         jmp     .22E
    79 000000EA 49                  <1> .22E:   dec     cx              ; 符号を付与した分、残りのバッファサイズ(cx=size)を減算
    80                              <1> .20E:
    81                              <1> 
    82                              <1>         ; ------------------
    83                              <1>         ; Ascii変換
    84                              <1>         ; ------------------
    85 000000EB 8B5E0A              <1>         mov     bx, [bp + 10]           ; BX = 基数を取得
    86                              <1> .30L:
    87 000000EE BA0000              <1>         mov     dx, 0                   ; 割り算の余りはdxに代入される。なので、事前に0初期化している。
    88 000000F1 F7F3                <1>         div     bx                      ; 基数(bx)で割り算(div)を行う
    89                              <1> 
    90 000000F3 89D6                <1>         mov     si, dx
    91 000000F5 8A94[1D01]          <1>         mov     dl, byte [.ascii + si]  ; 割り算の余りから、Asciiテーブルを参照
    92                              <1> 
    93 000000F9 8815                <1>         mov     [di], dl                ; di(変換後のバッファアドレスの末尾)にAscii文字を設定
    94 000000FB 4F                  <1>         dec     di                      ; 末尾の１つ前が次のAscii文字設定先であるため、減算(dec)する
    95                              <1> 
    96                              <1>         ; 割り算対象の値は暗黙的にax(変換対象の数値)が使用される
    97                              <1>         ; loopnz命令により、残りのバッファサイズ(cx)か変換対象(az)が0になるまで、ループを繰り返す
    98 000000FC 83F800              <1>         cmp     ax, 0
    99 000000FF E0ED                <1>         loopnz  .30L
   100                              <1> .30E:
   101                              <1> 
   102                              <1>         ; ------------------
   103                              <1>         ; 空欄を埋める
   104                              <1>         ; ------------------
   105 00000101 83F900              <1>         cmp     cx, 0                   ; バッファサイズ(cx)が残っている場合に、空欄埋めを行う
   106 00000104 740D                <1> .40Q:   je      .40E
   107 00000106 B020                <1>         mov     al, ' '
   108 00000108 837E0C04            <1>         cmp     [bp + 12], word 0b0100
   109 0000010C 7502                <1> .42Q:   jne     .42E
   110 0000010E B030                <1>         mov     al, '0'
   111                              <1> .42E:
   112 00000110 FD                  <1>         std                             ; DF=0をセット
   113 00000111 F3AA                <1>         rep stosb                       ; rep命令を置くことで、cxレジスタが0になるまで、後続のstosb命令を繰り返す。その際、stosb命令実行後にcxレジスタの減算を行う。
   114                              <1> .40E:
   115                              <1> 
   116                              <1>     ; レジスタの復帰
   117 00000113 5F                  <1>     pop di
   118 00000114 5E                  <1>     pop si
   119 00000115 5A                  <1>     pop dx
   120 00000116 59                  <1>     pop cx
   121 00000117 5B                  <1>     pop bx
   122 00000118 58                  <1>     pop ax
   123                              <1> 
   124                              <1>     ; スタックフレームの破棄
   125 00000119 89EC                <1>     mov sp, bp
   126 0000011B 5D                  <1>     pop bp
   127                              <1> 
   128 0000011C C3                  <1>     ret
   129                              <1> 
   130 0000011D 303132333435363738- <1> .ascii  db      "0123456789ABCDEF" ;変換デーブル
   130 00000126 39414243444546      <1>
    44                                  %include        "../modules/real/reboot.s"
     1                              <1> reboot:
     2                              <1>     ; 再起動の説明を出力
     3 0000012D 68[4901]E859FF83C4- <1>     cdecl   puts, .s0
     3 00000135 02                  <1>
     4                              <1> 
     5                              <1> .10L:
     6                              <1>     ; キー入力待ち
     7 00000136 B410                <1>     mov     ah, 0x10
     8 00000138 CD16                <1>     int     0x16
     9                              <1> 
    10                              <1>     ; キー入力が空白文字ではない場合、再度キー入力待ちへ戻る
    11 0000013A 3C20                <1>     cmp     al, ' '
    12 0000013C 75F8                <1>     jne     .10L
    13                              <1> 
    14                              <1>     ; 改行出力
    15 0000013E 68[6701]E848FF83C4- <1>     cdecl   puts, .s1
    15 00000146 02                  <1>
    16                              <1> 
    17                              <1>     ; 再起動
    18 00000147 CD19                <1>     int     0x19
    19                              <1> 
    20                              <1> 
    21                              <1>     ; 文字列データ
    22 00000149 0A0D50757368205350- <1> .s0     db 0x0A, 0x0D, "Push SPACE Key to reboot...", 0
    22 00000152 414345204B65792074- <1>
    22 0000015B 6F207265626F6F742E- <1>
    22 00000164 2E2E00              <1>
    23 00000167 0A0D0A0D00          <1> .s1     db 0x0A, 0x0D, 0x0A, 0x0D, 0
    24                              <1> 
    45                                  
    46 0000016C 00<rept>                        times 510 - ($ - $$) db 0x00
    47 000001FE 55AA                            db 0x55, 0xAA
